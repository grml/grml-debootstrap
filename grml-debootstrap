#!/bin/bash
# Filename:      grml-debootstrap
# Purpose:       wrapper around debootstrap for installing plain Debian via Grml
# Authors:       grml-team (grml.org), (c) Michael Prokop <mika@grml.org>
# Bug-Reports:   see http://grml.org/bugs/
# License:       This file is licensed under the GPL v2+
################################################################################

# variables {{{
PN="$(basename "$0")"
VERSION="$(dpkg-query --show --showformat='${Version}' "$PN")"
VERSION="${VERSION:-unknown}"
MNTPOINT="/mnt/debootstrap.$$"

# defaults
[ -n "$CHROOT_SCRIPTS" ] || CHROOT_SCRIPTS='yes'
[ -n "$CONFFILES" ] || CONFFILES='/etc/debootstrap'
[ -n "$DEBCONF" ] || DEBCONF='yes'
[ -n "$DEBIAN_FRONTEND" ] || DEBIAN_FRONTEND='noninteractive'
[ -n "$DEBOOTSTRAP" ] || DEBOOTSTRAP='debootstrap'
[ -n "$DEFAULT_LANGUAGE" ] || DEFAULT_LANGUAGE='en_US:en'
[ -n "$DEFAULT_LOCALES" ] || DEFAULT_LOCALES='en_US.UTF-8'
[ -n "$DISK_IDENTIFIER" ] || DISK_IDENTIFIER='26ada0c0-1165-4098-884d-aafd2220c2c6'
[ -n "$EXTRAPACKAGES" ] || EXTRAPACKAGES='yes'
[ -n "$FALLBACK_MIRROR" ] || FALLBACK_MIRROR='http://http.debian.net/debian'
[ -n "$FIXED_DISK_IDENTIFIERS" ] || FIXED_DISK_IDENTIFIERS="no"
[ -n "$FORCE" ] || FORCE=''
[ -n "$HOSTNAME" ] || HOSTNAME='grml'
[ -n "$INITRD" ] || INITRD='yes'
[ -n "$INSTALL_NOTES" ] || INSTALL_NOTES='/etc/debootstrap/install_notes'
[ -n "$LOCALES" ] || LOCALES='yes'
[ -n "$MIRROR" ] || MIRROR="$FALLBACK_MIRROR"
[ -n "$MKFS" ] || MKFS='mkfs.ext4'
[ -n "$MKFS_OPTS" ] || MKFS_OPTS=''
[ -n "$PACKAGES" ] || PACKAGES='yes'
[ -n "$PRE_SCRIPTS" ] || PRE_SCRIPTS='yes'
[ -n "$RECONFIGURE" ] || RECONFIGURE='console-data'
[ -n "$RELEASE" ] || RELEASE='jessie'
[ -n "$RM_APTCACHE" ] || RM_APTCACHE='yes'
[ -n "$SCRIPTS" ] || SCRIPTS='yes'
[ -n "$SECURE" ] || SECURE='yes'
[ -n "$TIMEZONE" ] || TIMEZONE='Europe/Vienna'
[ -n "$TUNE2FS" ] || TUNE2FS='tune2fs -c0 -i0'
[ -n "$UPGRADE_SYSTEM" ] || UPGRADE_SYSTEM='yes'
[ -n "$VMSIZE" ] || VMSIZE="2G"

# inside the chroot system locales might not be available, so use minimum:
export LANG=C
export LC_ALL=C

# make sure interactive mode is only executed when
# using an empty configuration file or option --interactive
INTERACTIVE=''
# }}}

# help text {{{
usage() {
  echo "$PN - wrapper around debootstrap for installing Debian

Usage: $PN [options]

Bootstrap options:

  -m, --mirror <URL>     Mirror which should be used for apt-get/aptitude.
  -i, --iso <mnt>        Mountpoint where a Debian ISO is mounted to, for use
                         instead of fetching packages from a mirror.
  -r, --release <name>   Release of new Debian system (default: jessie).
  -t, --target <target>  Target partition (/dev/...) or directory where the
                         system should be installed to.
  -p, --mntpoint <mnt>   Mountpoint used for mounting the target system,
                         has no effect if -t is given and represents a directory.
      --debopt <params>  Extra parameters passed to the debootstrap command.
      --interactive      Use interactive mode (frontend).
      --nodebootstrap    Skip debootstrap, only do configuration to the target.
      --grub <device>    Target for grub installation. Usage example: /dev/sda
      --arch <arch>      Set target architecture, use for installing i386 on amd64.
      --filesystem <fs>  Filesystem that should be used when target is a partition
                         or Virtual Machine (see --vmfile).
      --force            Do not prompt for user acknowledgement.

Options for Virtual Machine deployment:

      --vm               Set up a Virtual Machine, instead of plainly installing
                         to a partition or directory, to be combined with --target,
                         like: --vm --target /dev/mapper/your-vm-disk
      --vmfile           Like --vm, but install into a file (raw format).
                         Example: --vmfile --target /mnt/sda1/qemu.img
      --vmsize <size>    Use specified size for size of VM file (default: 2G).
                         Syntax as supported by qemu-img, like: --vmsize 3G

Configuration options:

  -c, --config <file>      Use specified configuration file, defaults to
                             /etc/debootstrap/config
  -d, --confdir <path>     Place of config files for debootstrap, defaults
                             to /etc/debootstrap
      --packages <file>    Install packages defined in specified list file
                             instead of using /etc/debootstrap/packages.
      --nopackages         Skip installation of packages defined in
                             /etc/debootstrap/packages
      --nokernel           Skip installation of default kernel images.
      --nointerfaces       Do not copy /etc/network/interfaces from host system
                           to target system.
                           (This option is automatically enabled when using --vmfile.)
      --defaultinterfaces  Install a default /etc/network/interfaces file (enabling
                           DHCP for eth0) instead of taking over config from host system.
      --debconf <file>     Pre-seed packages using specified pre-seed db file.
      --grmlrepos          Enable Grml's Debian repository (deb.grml.org).
      --backportrepos      Enable Debian's backports repository (backports.debian.org).
      --keep_src_list      Do not overwrite user provided apt sources.list.
      --hostname <name>    Hostname of Debian system.
      --nopassword         Do not prompt for the root password.
      --password <pwd>     Use specified password as password for user root.
      --bootappend <line>  Add specified appendline to kernel whilst booting.
      --chroot-scripts <d> Execute chroot scripts from specified directory.
      --pre-scripts <dir>  Execute scripts from specified directory (before chroot-scripts).
      --scripts <dir>      Execute scripts from specified directory (after chroot-scripts).

Other options:

  -v, --verbose            Increase verbosity.
      --debug              Execute in very verbose way.
  -h, --help               Print this usage information and exit.
  -V, --version            Show summary of options and exit.

Usage examples can be found in the grml-debootstrap manpage.
Send bugreports to the grml-team: bugs (at) grml.org || http://grml.org/bugs/
"
}

if [ "$1" = '-h' ] || [ "$1" = '-help' ] || [ "$1" = "--help" ] ; then
   usage
   echo 'Please notice that this script requires root permissions!'
   exit 0
fi
# }}}

# early helper functions {{{
GOOD='[32;01m'
BAD='[31;01m'
WARN='[33;01m'
NORMAL='[0m'

einfo() {
  einfon "$1\n"
  return 0
}

einfon() {
  [ "${RC_ENDCOL}" != "yes" ] && [ "${LAST_E_CMD}" = "ebegin" ] && echo
  printf " ${GOOD}*${NORMAL} $*"
  LAST_E_CMD=einfon
  return 0
}

ewarn() {
  printf " ${WARN}*${NORMAL} $*\n"
  return 0
}

eerror() {
  [ "${RC_ENDCOL}" != "yes" ] && [ "${LAST_E_CMD}" = "ebegin" ] && echo
  printf " ${BAD}*${NORMAL} $*\n" >&2
  LAST_E_CMD=eerror
  return 0
}

eend() {
  local retval="${1:-0}"
  shift
  if [ "$retval" -gt 0 ]; then
    printf " ${BAD}-> Failed (rc=${retval})${NORMAL}\n"
  fi
  return "$retval"
}

check4root(){
  if [ "$(id -u 2>/dev/null)" != 0 ] ; then
    echo 1>&2 "Error: please run this script with uid 0 (root)." ; return 1
  fi
}

check4progs(){
  local RC=''
  for arg in "$@" ; do
    which "$arg" >/dev/null 2>&1 || RC="$arg"
  done
  if [ -n "$RC" ] ; then
     echo "$RC not installed"
     return 1
  fi
}
# }}}

# helper functions {{{
cleanup() {
  if [ -n "$CHROOT_VARIABLES" ] ; then
    einfo "Removing ${CHROOT_VARIABLES}" ; rm "$CHROOT_VARIABLES" ; eend $?
  fi

  if [ -n "$STAGES" ] ; then
    einfo "Removing ${STAGES}" ; rmdir "$STAGES" ; eend $?
  fi

  # Remove temporary mountpoint again
  if echo "$MNTPOINT" | grep -q '/mnt/debootstrap\.' ; then
    rmdir "$MNTPOINT" 2>/dev/null
  fi

  # make sure $TARGET is not mounted when exiting grml-debootstrap
  if [ -n "$MNTPOINT" ] ; then
    if grep -q "$MNTPOINT" /proc/mounts ; then
      # make sure nothing is left inside chroot so we can unmount it
      for service in ssh mdadm ; do
        if [ -x "${MNTPOINT}/etc/init.d/${service}" ] ; then
          chroot "$MNTPOINT" "/etc/init.d/${service}" stop
        fi
      done

      [ -x "$MNTPOINT"/bin/umount ] && chroot "$MNTPOINT" umount -a >/dev/null 2>&1

      # ugly, but make sure we really don't leave anything (/proc /proc and
      # /dev /dev are intended, trying to work around timing issues, see #657023)
      for ARG in /sys /proc /proc /dev /dev ; do
        [ -x "$MNTPOINT"/bin/umount ] && chroot "$MNTPOINT" umount $ARG >/dev/null 2>&1
        umount "$MNTPOINT"/$ARG >/dev/null 2>&1
      done

      if [ -n "$ISODIR" ] ; then
        [ -d "$MNTPOINT/$ISODIR" ] && umount "$MNTPOINT/$ISODIR" >/dev/null 2>&1
      fi

      if [ -n "$DIRECTORY" ] ; then
        einfo "Not unmounting $MNTPOINT as you requested me to install into a directory of your own choice." ; eend 0
      else
        einfo "Unmounting $MNTPOINT"
        umount "$MNTPOINT"
        eend $?
      fi

      if [ -n "$STAGES" ] ; then
        echo -n "Removing stages directory ${STAGES}: "
        rm -rf "$STAGES" && echo 'done'
      fi

      # remove directory only if we used the default with process id inside the name
      if echo "$MNTPOINT" | grep -q '/mnt/debootstrap\.' ; then
        einfo "Removing directory ${MNTPOINT}"
        rmdir "$MNTPOINT"
        eend $?
      fi
    fi
  fi

  if [ -n "${ORIG_TARGET}" ] ; then
    einfo "Removing loopback mount of file ${ORIG_TARGET}."
    kpartx -d "${ORIG_TARGET}" ; eend $?
  fi
}

# we want to exit smoothly and clean:
bailout(){

  cleanup

  [ -n "$1" ] && EXIT="$1" || EXIT="1"
  [ -n "$2" ] && einfo "Notice: remove $STAGES/$2 to reexecute the stage"

  exit "$EXIT"
}
trap bailout HUP INT QUIT TERM

# we want to execute all the functions only once, simple check for it:
stage() {
  if [ -n "$2" ] ; then
     echo "$2" > "${STAGES}/${1}"
     return 0
  elif grep -q 'done' "${STAGES}/${1}" 2>/dev/null ; then
     ewarn "Notice: stage $1 has been executed already, skipping execution therefore." ; eend 0
     ewarn "  To reexecute it clean up the according directory inside $STAGES" ; eend 0
     return 1
  fi
}
# }}}

# make sure we have what we need {{{
check4progs debootstrap || bailout 1
# }}}

# source main configuration file {{{
if [ -r /etc/debootstrap/config ] ; then
  . /etc/debootstrap/config
fi
# }}}

# cmdline handling {{{
# source external command line parameter-processing script
self_dir="$(dirname "$(which "$0")")"
if [ -r "${self_dir}"/cmdlineopts.clp ] ; then
   . "${self_dir}"/cmdlineopts.clp
elif [ -r /usr/share/grml-debootstrap/functions/cmdlineopts.clp ] ; then
   . /usr/share/grml-debootstrap/functions/cmdlineopts.clp
else
   eerror "Error: cmdline function file not found, exiting."
   eend 1
   bailout 1
fi

# == business-logic of command line parameter-processing

# source configuration file in <confdir> if supplied. {{{
[ "$_opt_confdir" ] && {
  CONFFILES=$_opt_confdir
  einfo "Using config files under $CONFFILES/."
  if ! [ -r "$CONFFILES/config" ] ; then
    eerror "Error: config file $CONFFILES/config not found."; eend 1; bailout 1
  fi
  if ! . "$CONFFILES/config" ; then
    eerror "Error reading config file $CONFFILES/config" ; eend 1 ; bailout 1
  fi
  # restore the command line parameter value
  CONFFILES=$_opt_confdir
}
# }}}

[ "$_opt_mirror" ]              && MIRROR=$_opt_mirror
[ "$_opt_iso" ]                 && ISO=$_opt_iso
[ "$_opt_release" ]             && RELEASE=$_opt_release
[ "$_opt_target" ]              && TARGET=$_opt_target
[ "$_opt_vm" ]                  && VIRTUAL=1
[ "$_opt_vmfile" ]              && VMFILE=1 && VIRTUAL=1
[ "$_opt_vmsize" ]              && VMSIZE=$_opt_vmsize
[ "$_opt_mntpoint" ]            && MNTPOINT=$_opt_mntpoint
[ "$_opt_debopt" ]              && DEBOOTSTRAP_OPT=$_opt_debopt
[ "$_opt_interactive" ]         && INTERACTIVE=1
[ "$_opt_config" ]              && CONFIGFILE=$_opt_config
[ "$_opt_filesystem" ]          && MKFS="mkfs.$_opt_filesystem"
[ "$_opt_packages_set" ]        && PACKAGES='yes'
[ "$_opt_nopackages" ]          && PACKAGES=''
[ "$_opt_debconf_set" ]         && DEBCONF='yes'
[ "$_opt_scripts_set" ]         && SCRIPTS='yes'
[ "$_opt_pre_scripts_set" ]     && PRE_SCRIPTS='yes'
[ "$_opt_chroot_scripts_set" ]  && CHROOT_SCRIPTS='yes'
[ "$_opt_keep_src_list" ]       && KEEP_SRC_LIST='yes'
[ "$_opt_grmlrepos" ]           && GRMLREPOS='yes'
[ "$_opt_backportrepos" ]       && BACKPORTREPOS='yes'
[ "$_opt_hostname" ]            && HOSTNAME=$_opt_hostname
[ "$_opt_password" ]            && ROOTPASSWORD=$_opt_password
[ "$_opt_nopassword" ]          && NOPASSWORD='yes'
[ "$_opt_defaultinterfaces" ]   && USE_DEFAULT_INTERFACES="true"
[ "$_opt_nointerfaces" ]        && NOINTERFACES="true"
[ "$_opt_nokernel" ]            && NOKERNEL="true"
[ "$_opt_bootappend" ]          && BOOT_APPEND=$_opt_bootappend
[ "$_opt_grub" ]                && GRUB=$_opt_grub
[ "$_opt_arch" ]                && ARCH=$_opt_arch
[ "$_opt_insecure" ]            && echo "Warning: --insecure is deprecated, continuing anyway."
[ "$_opt_force" ]               && FORCE=$_opt_force
[ "$_opt_verbose" ]             && VERBOSE="-v"
[ "$_opt_debug" ]               && DEBUG="true"

if [ "$DEBUG" = "true" ] ; then
  set -x
fi

[ "$_opt_help" ] && {
  usage ; eend 0
  eend 0
  exit 0
}

[ "$_opt_version" ] && {
  einfo "$PN - version $VERSION"
  einfo "Send bug reports to bugs@grml.org or http://grml.org/bugs/"
  eend 0
  exit 0
}
# }}}

# check for root permissions {{{
if ! check4root ; then
   echo "For usage instructions please execute '$PN --help'."
   bailout 1
fi
# }}}

# make sure we have what we need {{{
if [ -n "$VIRTUAL" ] ; then
  check4progs kpartx mksh parted qemu-img || bailout 1
fi
# }}}

# source specified configuration file {{{
if [ -n "$CONFIGFILE" ] ; then
   einfo "Reading specified config file $CONFIGFILE."
   if ! . "$CONFIGFILE" ; then
      eerror "Error reading config file $CONFIGFILE" ; eend 1 ; bailout 1
   fi
fi
# }}}

# backwards compability checks {{{
if [ -n "$GROOT" ] ; then
   eerror "Error: you seem to have \$GROOT configured."
   eerror "This variable is no longer supported, please visit the"
   eerror "grml-debootstrap documentation for details."
   eend 1
   bailout 1
fi

if echo "$GRUB" | grep -q '^hd' ; then
   eerror "Error: this syntax for the grub configuration variable is no longer supported."
   eerror "Please do not use hd... any longer but /dev/sdX instead."
   eend 1
   bailout 1
fi
# }}}

# welcome screen {{{
welcome_dialog()
{
   dialog --title "$PN" --yesno "Welcome to the interactive configuration of ${PN}.
Do you want to continue installing Debian using this frontend?" 0 0 || bailout 0
}
# }}}

# ask for target {{{
prompt_for_target()
{
  AVAILABLE_PARTITIONS=$(LANG=C fdisk -l 2>/dev/null | \
               sed 's/*//' | \
               grep -v 'Extended$' | \
               gawk -v num=0 -v ORS=' ' '/^\/dev\// {print $1}'; ls /dev/md[0-9]* 2>/dev/null || true);

  if [ -z "$AVAILABLE_PARTITIONS" ] ; then
     dialog --title "$PN" --trim \
     --msgbox "Sorry, no partitions found. Please configure your
     harddisks (see /proc/partitions) using a tool like fdisk,
     cfdisk, gpart, gparted,..." 0 0
     bailout 1
  fi

  PARTITION_LIST=$(for i in $AVAILABLE_PARTITIONS ; do
                     fs="$(blkid -s TYPE -o value "$i" 2>/dev/null)"
                     [ -n "$fs" ] || fs='[no_filesystem_yet]'
                     echo "$i" "$fs"
                     unset fs
                   done)

  TARGET=$(dialog --title "$PN" --single-quoted --stdout \
         --menu "Please select the target partition:" 0 0 0 \
         $PARTITION_LIST)
  [ $? -eq 0 ] || bailout 1
}
# }}}

# ask for bootmanager {{{
prompt_for_bootmanager()
{
  ADDITIONAL_PARAMS=""

  if echo "$TARGET" | grep -q "/dev/md" ; then
     MBRPART="all disks of Software RAID $TARGET"
  else
     # figure out whole disk device
     found=
     for device in /dev/disk/by-id/*
     do
        [ "$(readlink -f "$device")" = "${TARGET}" ] || continue
        found=1
        break
     done
     [ -n "$found" ] && MBRDISK=$(echo "${device}" |sed -e 's/-part[0-9][0-9]*$//')
     if [ -e "$MBRDISK" ]; then
        MBRDISK=$(readlink -f "$MBRDISK")
     else
        # fall back to old behaviour
        MBRDISK=$(echo "${TARGET}" | sed -e 's/[0-9][0-9]*$//')
     fi

     MBRPART="MBR of $MBRDISK"
  fi

  for device in cciss/c0d0 sda hda; do
    if [ "/dev/$device" != "${MBRDISK}" ]; then
      grep -q $device /proc/partitions && \
      ADDITIONAL_PARAMS="$ADDITIONAL_PARAMS:$device:install bootmanager grub into MBR of /dev/$device"
    fi
  done
  ADDITIONAL_PARAMS=${ADDITIONAL_PARAMS#:}

  OIFS="$IFS"; IFS=:

  GETMBR=$(dialog --stdout --title "$PN" --default-item mbr \
          --menu "Where do you want to install the bootmanager grub?" 0 0 0 \
            mbr       "install bootmanager into $MBRPART" \
            nowhere   "do not install bootmanager at all" \
          ${ADDITIONAL_PARAMS})
  [ $? -eq 0 ] || bailout 3
  IFS="$OIFS"

  case "$GETMBR" in
    mbr)
      # /dev/md0: has to be installed in MBR of /dev/md0 and not in /dev/md:
      if echo "$TARGET" | grep -q "/dev/md" ; then
        GRUB="$TARGET"
      else
        GRUB="$MBRDISK"
      fi
      ;;
    hda)
      GRUB="/dev/hda"
      ;;
    sda)
      GRUB="/dev/sda"
      ;;
    nowhere)
      GRUB=''
      ;;
  esac
}
# }}}

# ask for Debian release {{{
prompt_for_release()
{
  [ -n "$RELEASE" ] && DEFAULT_RELEASE="$RELEASE" || DEFAULT_RELEASE='jessie'
  RELEASE="$(dialog --stdout --title "${PN}" --default-item $DEFAULT_RELEASE --menu \
            "Please enter the Debian release you would like to use for installation:" \
            0 50 5 \
            lenny    Debian/5.0 \
            squeeze  Debian/6.0 \
            wheezy   Debian/7.0 \
            jessie   Debian/8.0 \
            sid      Debian/unstable)"
  [ $? -eq 0 ] || bailout
}
# }}}

# ask for hostname {{{
prompt_for_hostname()
{
  HOSTNAME="$(dialog --stdout --title "${PN}" --inputbox \
            "Please enter the hostname you would like to use for installation:" \
            0 0 "$HOSTNAME")"
  [ $? -eq 0 ] || bailout
}
# }}}

# ask for password {{{
prompt_for_password()
{
  if [ "$_opt_nopassword" ] ; then
    einfo "Skip asking for root password as requested."
    return 0
  fi

  ROOTPW1='PW1'
  ROOTPW2='PW2'
  while [ "$ROOTPW1" != "$ROOTPW2" ]; do
    ROOTPW1=$(dialog --insecure --stdout --title "${PN}" --passwordbox \
    "Please enter the password for the root account:" 10 60)
    [ $? -eq 0 ] || bailout

    ROOTPW2=$(dialog --insecure --stdout --title "${PN}" --passwordbox \
    "Please enter the password for the root account again for \
    confirmation:" 10 60)
    [ $? -eq 0 ] || bailout

    if [ "$ROOTPW1" != "$ROOTPW2" ]; then
      dialog --stdout --title "${PN}" --ok-label \
        "Retry" --msgbox "Passwords do not match!" 10 60
    fi
  done
  ROOTPASSWORD="$ROOTPW1"
}
# }}}

# ask for Debian mirror {{{
prompt_for_mirror()
{
  [ -n "$ISO" ] && DEFAULT_MIRROR='local' || DEFAULT_MIRROR='net'

  CHOOSE_MIRROR=$(dialog --stdout --title "$PN" --default-item $DEFAULT_MIRROR \
          --menu "Where do you want to install from?" 0 0 0 \
            net   "install via network (downloading from mirror)" \
            local "install from local directory/mirror"
          )
  [ $? -eq 0 ] || bailout

  if [ "$CHOOSE_MIRROR" = 'net' ] ; then
     [ -n "$MIRROR" ] || MIRROR='http://http.debian.net/debian'
     MIRROR="$(dialog --stdout --title "${PN}" --inputbox \
               "Please enter Debian mirror you would like to use for installing packages." \
               0 0 $MIRROR)"
     [ $? -eq 0 ] || bailout
  else # CHOOSE_MIRROR == local
     [ -n "$ISO" ] || ISO='/mnt/mirror'
     ISO="$(dialog --stdout --title "${PN}" --inputbox \
               "Please enter directory name you would like to use for installing packages." \
               0 0 $ISO)"
     [ $? -eq 0 ] || bailout
  fi
}
# }}}

# software raid setup {{{
config_swraid_setup()
{
TMPFILE=$(mktemp)

# Currently we support only raid1:
RAIDLEVEL='raid1'

MD_LIST=$(for i in $(seq 0 9) ; do
            awk '{print $4}' /proc/partitions | grep -q "md$i" || \
            echo "/dev/md$i /dev/md$i"
          done)

TARGET=$(dialog --stdout --title "$PN" --default-item /dev/md0 \
--menu "Which device do you want to use for ${RAIDLEVEL}?

Notice: activated devices will not be listed for security reasons. Anyway, please make sure the selected device is not in use already!" 0 0 0 \
$MD_LIST)
[ $? -eq 0 ] || bailout 20

AVAILABLE_PARTITIONS=$(LANG=C fdisk -l 2>/dev/null | \
             sed 's/*//' | \
             grep -v 'Extended$' | \
             gawk -v num=0 -v ORS=' ' '/^\/dev\// {print $1}')
[ -n "$AVAILABLE_PARTITIONS" ] || echo "Fatal error: no partitions available?"
PARTITION_LIST=$(for i in $AVAILABLE_PARTITIONS ; do
                     echo "$i $(blkid -s TYPE -o value "$i" 2>/dev/null || echo '[no_filesystem_yet]') off"
                 done)

dialog --title "$PN" --separate-output \
       --checklist "Please select the partitions you would like to use for your $RAIDLEVEL on ${TARGET}:" 0 0 0 \
       $PARTITION_LIST 2>"$TMPFILE"
[ $? -eq 0 ] || bailout
SELECTED_PARTITIONS="$(cat "$TMPFILE")"

NUM_PARTITIONS=0
for i in $(cat "$TMPFILE") ; do
   NUM_PARTITIONS=$(( NUM_PARTITIONS + 1 ))
done

# force metadata version 0.90 for lenny so old grub can boot from this array.
METADATA_VERSION=""
if [ "$RELEASE" = "lenny" ]; then
   METADATA_VERSION="-e0"
fi

ERRORFILE=$(mktemp)
yes | mdadm --create "${TARGET}" --level="${RAIDLEVEL}" \
      --raid-devices="${NUM_PARTITIONS}" ${METADATA_VERSION} ${SELECTED_PARTITIONS} >/dev/null 2>$ERRORFILE
RC=$?
if [ "$RC" = 0 ] ; then
   dialog --title "$PN" --msgbox \
   "Creating $TARGET was successful." 0 0
   rm -f "$TMPFILE" "$ERRORFILE"
else
   dialog --title "$PN" --msgbox \
   "There was an error setting up $TARGET:

$(cat "$ERRORFILE")

Exiting." 0 0
   rm -f "$TMPFILE" "$ERRORFILE"
   bailout 1
fi

}

prompt_for_swraid()
{
if dialog --stdout --title "$PN" \
          --defaultno --yesno "Do you want to configure Software RAID?

Please notice that only RAID level 1 is supported by ${PN} currently. Configuration will take place using mdadm." 0 0 ; then
  config_swraid_setup
fi
}
# }}}

# user should recheck his configuration {{{
# support full automatic installation:
checkforrun() {
   dialog --timeout 10 --title "$PN" \
          --yesno "Do you want to stop at this stage?

Notice: you are running ${PN} in non-interactive mode.
${PN} will install Debian ${RELEASE} on ${TARGET}.
Last chance to quit. Timeout of 10 seconds running....

Do you want to stop now?" 0 0 2>/dev/null
}
# }}}

# make sure the user is aware of the used configuration {{{
checkconfiguration()
{
if [ -n "$AUTOINSTALL" ] ; then
   if checkforrun ; then
      eerror "Exiting as requested" ; eend 0
      bailout 1
   fi
elif [ -n "$INTERACTIVE" ] ; then

   INFOTEXT="Please recheck configuration before execution:
   "
   [ -n "$TARGET" ]  && INFOTEXT="$INFOTEXT
   Target:          $TARGET"
   [ -n "$GRUB" ]    && INFOTEXT="$INFOTEXT
   Install grub:    $GRUB"
   [ -n "$RELEASE" ] && INFOTEXT="$INFOTEXT
   Using release:   $RELEASE"
   [ -n "$HOSTNAME" ] && INFOTEXT="$INFOTEXT
   Using hostname:  $HOSTNAME"
   [ -n "$MIRROR" ]  && INFOTEXT="$INFOTEXT
   Using mirror:    $MIRROR"
   [ -n "$ISO" ]  && INFOTEXT="$INFOTEXT
   Using ISO:       $ISO"
   [ -n "$ARCH" ]  && INFOTEXT="$INFOTEXT
   Using arch:      $ARCH"

   INFOTEXT="$INFOTEXT

Is this ok for you? Notice: selecting 'No' will exit ${PN}."

   dialog --title "$PN" --no-collapse \
          --yesno "$INFOTEXT" 0 0
   [ $? -eq 0 ] || bailout 0

else # if not running automatic installation display configuration and prompt for execution:
   einfo "$PN [${VERSION}] - Please recheck configuration before execution:"
   echo
   echo "   Target:          $TARGET"

   # do not display if MNTPOINT is the default one
   case "$MNTPOINT" in /mnt/debootstrap*) ;; *) echo "   Mount point:     $MNTPOINT" ;; esac

   if [ -n "$VIRTUAL" ] ; then
      echo "   Install grub:    yes"
   else
     [ -n "$GRUB" ]     && echo "   Install grub:    $GRUB" || echo "   Install grub:    no"
   fi

   [ -n "$RELEASE" ]  && echo "   Using release:   $RELEASE"
   [ -n "$HOSTNAME" ] && echo "   Using hostname:  $HOSTNAME"
   [ -n "$MIRROR" ]   && echo "   Using mirror:    $MIRROR"
   [ -n "$ISO" ]      && echo "   Using ISO:       $ISO"
   [ -n "$ARCH" ]     && echo "   Using arch:      $ARCH"
   if [ -n "$VIRTUAL" ] ; then
      echo "   Deploying as Virtual Machine."
      if [ -n "$VMSIZE" -a -n "$VMFILE" ]; then
         echo "   Using Virtual Disk file with size of ${VMSIZE}."
      fi
   fi

   if [ ! -t 0 -a -z "$ROOTPASSWORD" -a -z "$NOPASSWORD" ] ; then
      echo
      echo "   You do not have a TTY allocated, your password will be shown in"
      echo "   plaintext on the terminal! If you are using SSH, try its -t option!"
   fi

   echo
   echo "   Important! Continuing will delete all data from ${TARGET}!"

   if [ -n "$FORCE" ] ; then
     einfo "Skip user acknowledgement as requested via --force option."
   else
     echo
     einfon "Is this ok for you? [y/N] "
     read a
     if ! [ "$a" = 'y' -o "$a" = 'Y' ] ; then
        eerror "Exiting as requested." ; eend 1
        bailout 1
     fi
   fi
fi
}
# }}}

# interactive mode {{{
interactive_mode()
{
  check4progs dialog || bailout 1

  welcome_dialog

  prompt_for_release

  prompt_for_swraid

  prompt_for_target

  prompt_for_bootmanager

  prompt_for_hostname

  prompt_for_password

  prompt_for_mirror
}

# run interactive mode if we didn't get the according configuration yet
if [ -z "$TARGET" -o -n "$INTERACTIVE" ] ; then
   # only target might be unset, so make sure the INTERACTIVE flag is set as well
   INTERACTIVE=1
   interactive_mode
fi
# }}}

# architecture setup {{{
if [ -n "$ARCH" ] ; then
   ARCHCMD="--arch $ARCH"
   ARCHINFO=" (${ARCH})"
else
   ARCH="$(dpkg --print-architecture)"
   ARCHCMD="--arch $ARCH"
   ARCHINFO=" (${ARCH})"
fi
# }}}

# It is not possible to build amd64 on i686. {{{
CURRENT_ARCH="$(uname -m)"
if [ "$CURRENT_ARCH" != "x86_64" ] ; then
   if [ "$ARCH" = "amd64" ] ; then
      eerror "It is not possible to build amd64 on $CURRENT_ARCH." ; eend 1
      bailout 1
   fi
fi
# }}}

checkconfiguration

# finally make sure at least $TARGET is set [the partition for the new system] {{{
if [ -n "$TARGET" ] ; then
   SHORT_TARGET="${TARGET##*/}"
else
   eerror "Please adjust $CONFFILES/config or..."
   eerror "... use the interactive version for configuration before running ${0}" ; eend 1
   bailout 1
fi
# }}}

# stages setup {{{
if [ -z "$STAGES" ] ; then
   STAGES="/var/cache/grml-debootstrap/stages_${SHORT_TARGET}"
   [ -d "$STAGES" ] || mkdir -p "$STAGES"
fi

if [ -r "$STAGES"/grml-debootstrap ] ; then
   if grep -q 'done' "${STAGES}/grml-debootstrap" ; then
      eerror "Error: grml-debootstrap has been executed already, won't continue therefore."
      eerror "If you want to re-execute grml-debootstrap just manually remove ${STAGES}" ; eend 1
   fi
fi
# }}}

# partition handling {{{
PARTITION=''
DIRECTORY=''

set_target_directory(){
    # assume we are installing into a directory, don't run mkfs and grub related stuff therefore
    DIRECTORY=1
    MNTPOINT="$TARGET"
    MKFS=''
    TUNE2FS=''
    FSCK=''
    # make sure we normalise the path to an absolute directory name so something like:
    #  mkdir -p foo/a bar/a; (cd foo; grml-debootstrap -t a)&; (cd bar; grml-debootstrap -t a)&; wait
    # works
    TARGET="$(readlink -f "$TARGET")"
}

if [ -b "$TARGET" ] || [ -n "$VIRTUAL" ] ; then
    PARTITION=1
else
    set_target_directory
fi
# }}}

# make sure we have the right syntax when using an iso image {{{
if [ -n "$ISO" ] ; then
   case $ISO in
      file*) # do nothing
      ;;
      *)
      ISO=file:$ISO
      ;;
   esac
fi
ISODIR=${ISO##file:}
ISODIR=${ISODIR%%/}
# }}}

# Debian ISOs do not contain signed Release files {{{
if [ -n "$ISO" ] ; then
    DEBOOTSTRAP_OPT="$DEBOOTSTRAP_OPT --no-check-gpg"
fi
# }}}

# create filesystem {{{
mkfs() {
  if [ -n "$DIRECTORY" ] ; then
     einfo "Running grml-debootstrap on a directory, skipping mkfs stage."
     return 0
  fi

  if grep -q "$TARGET" /proc/mounts ; then
    eerror "$TARGET already mounted, exiting to avoid possible damage. (Manually unmount $TARGET)" ; eend 1
    bailout 1
  fi

  # mkfs.ext* might prompt with "/dev/sdX# contains a ext* file system
  # created on ... Proceed anyway? (y,n)" which we want to skip in force mode
  if [ -n "$MKFS" ] && [ -n "$FORCE" ] ; then
    case "$MKFS" in
      mkfs.ext*)
        einfo "Enabling force option (-F) for mkfs.ext* tool as requested via --force switch."
        MKFS_OPTS="$MKFS_OPTS -F"
        eend 0
        ;;
    esac
  fi

  if [ -n "$MKFS" ] ; then
    einfo "Running $MKFS $MKFS_OPTS on $TARGET"
    "$MKFS" $MKFS_OPTS "$TARGET" ; RC=$?

    if [ "$FIXED_DISK_IDENTIFIERS" = "yes" ] ; then
      if ! echo "$MKFS" | grep -q "mkfs.ext" ; then
        eerror "Not changing disk uuid for $TARGET because $MKFS doesn't seem to match for ext{2,3,4} file system"
        eend 1
        bailout 1
      else
        einfo "Changing disk uuid for $TARGET to fixed (non-random) value $DISK_IDENTIFIER using tune2fs"
        tune2fs "$TARGET" -U "$DISK_IDENTIFIER"
        eend $?
      fi
    fi

    # make sure /dev/disk/by-uuid/... is up2date, otherwise grub
    # will fail to detect the uuid in the chroot
    if echo "$TARGET" | grep -q "/dev/md" ; then
      blockdev --rereadpt "${TARGET}"
    elif ! [ -n "$VIRTUAL" ] ; then
      blockdev --rereadpt "${TARGET%%[0-9]*}"
    fi
    # give the system 2 seconds, otherwise we might run into
    # race conditions :-/
    sleep 2

    eval "$(blkid -o udev "$TARGET" 2>/dev/null)"
    [ -n "$ID_FS_UUID" ] && TARGET_UUID="$ID_FS_UUID" || TARGET_UUID=""

    eend $RC
  fi
}
# }}}

# modify filesystem settings {{{
tunefs() {
  if [ -n "$TUNE2FS" ] && echo "$MKFS" | grep -q "mkfs.ext" ; then
     einfo "Disabling automatic filesystem check on $TARGET via tune2fs"
     $TUNE2FS "$TARGET"
     eend $?
  fi
}
# }}}

# mount the new partition or if it's a directory do nothing at all {{{
mount_target() {
  if [ -n "$DIRECTORY" ] ; then
     einfo "Running grml-debootstrap on a directory, nothing to mount."
  else
     if grep -q "$TARGET" /proc/mounts ; then
        ewarn "$TARGET already mounted, continuing anyway." ; eend 0
     else
       if ! [ -d "${MNTPOINT}" ] ; then
          [ -n "$VIRTUAL" ] || mkdir -p "${MNTPOINT}"
       fi
       einfo "Mounting $TARGET to $MNTPOINT"
       mkdir -p "$MNTPOINT"
       mount -o rw,suid,dev "$TARGET" "$MNTPOINT"
       eend $?
     fi
  fi
  if [ -n "$ISODIR" ] ; then
     einfo "Mounting Debian image loopback to $MNTPOINT/$ISODIR."
     mkdir -p "$MNTPOINT/$ISODIR"
     mount --bind "$ISODIR" "$MNTPOINT/$ISODIR"
     eend $?
  fi
}
# }}}

# prepare VM image for usage with debootstrap {{{
prepare_vm() {
  if [ -z "$VIRTUAL" ] ; then
     return 0 # be quiet by intention
  fi

  if [ -b "$TARGET" -a -n "$VMFILE" ] ; then
     eerror "Error: specified virtual disk target ($TARGET) is an existing block device."
     eend 1
     bailout 1
  fi
  if [ ! -b "$TARGET" -a -z "$VMFILE" ] ; then
     eerror "Error: specified virtual disk target ($TARGET) does not exist yet."
     eend 1
     bailout 1
  fi

  ORIG_TARGET="$TARGET" # store for later reuse

  if [ -n "$VMFILE" ]; then
    qemu-img create -f raw "${TARGET}" "${VMSIZE}"
  fi
  echo 4 66 | /usr/share/grml-debootstrap/bootgrub.mksh -A | dd of="$TARGET" conv=notrunc
  dd if=/dev/zero bs=1 conv=notrunc count=64 seek=446 of="$TARGET"
  if [ "$FIXED_DISK_IDENTIFIERS" = "yes" ] ; then
    einfo "Adjusting disk signature to a fixed (non-random) value"
    MBRTMPFILE=$(mktemp)
    dd if="${TARGET}" of="${MBRTMPFILE}" bs=512 count=1
    echo -en "\x41\x41\x41\x41\x41" | dd of="${MBRTMPFILE}" conv=notrunc seek=440 bs=1
    dd if="${MBRTMPFILE}" of="${TARGET}" conv=notrunc
    eend $?
  fi
  parted -s "${TARGET}" 'mkpart primary ext4 2M -1'

  # if dm-mod isn't available then kpartx will fail with
  # "Is device-mapper driver missing from kernel? [...]"
  if ! kpartx -av "$TARGET" >/dev/null 2>&1 || ! grep -q 'device-mapper' /proc/misc >/dev/null 2>&1 ; then
    einfo "Device-mapper not ready yet, trying to load dm-mod module."
    modprobe dm-mod ; eend $?
  fi

  # make sure loop module is present
  if ! losetup -f >/dev/null 2>&1; then
    einfo "Can not find a usable loop device, retrying after loading loop module."
    modprobe loop
    if losetup -f >/dev/null 2>&1; then
      einfo "Found a usable loop device now, continuing."
    else
      eerror "Error finding usable loop device" ; eend 1
      bailout 1
    fi
  fi

  DEVINFO=$(kpartx -asv "$TARGET") # 'add map loop1p1 (253:0): 0 6289408 linear /dev/loop1 2048'
  if [ -z "${DEVINFO}" ] ; then
    eerror "Error setting up loopback device." ; eend 1
    bailout 1
  fi

  # hopefully this always works as expected
  LOOP=$(echo "${DEVINFO}" | sed 's/.* linear //; s/ [[:digit:]]*//') # 'loop1'
  LOOP_PART="$(echo "${DEVINFO##add map }" | sed 's/ .*//')" # 'loop1p1'
  export TARGET="/dev/mapper/$LOOP_PART" # '/dev/mapper/loop1p1'

  blockdev --rereadpt "${LOOP}"

  if [ -z "$TARGET" ] ; then
     eerror "Error: target could not be set to according /dev/mapper/* device." ; eend 1
     bailout 1
  fi
}
# }}}

# make VM image bootable and unmount it {{{
finalize_vm() {
  if [ -z "${VIRTUAL}" ] ; then
     return 0
  fi

  if ! mount "${TARGET}" "${MNTPOINT}" ; then
    eerror "Error: Mounting ${TARGET} failed, can not continue." ; eend 1
    bailout 1
  fi

  einfo "Installing Grub as bootloader."
  mount -t proc none "${MNTPOINT}"/proc
  mount -t sysfs none "${MNTPOINT}"/sys
  mount --bind /dev "${MNTPOINT}"/dev

  mkdir -p "${MNTPOINT}/boot/grub"
  if ! [ -d "${MNTPOINT}"/usr/lib/grub/i386-pc/ ] ; then
     eerror "Error: grub not installed inside Virtual Machine. Can not install bootloader." ; eend 1
     bailout 1
  fi

  case "$RELEASE" in
    lenny|squeeze|wheezy)
      cp "${MNTPOINT}"/usr/lib/grub/i386-pc/* "${MNTPOINT}/boot/grub/"
      ;;
    *)
      cp -a "${MNTPOINT}"/usr/lib/grub/i386-pc "${MNTPOINT}/boot/grub/"
      ;;
  esac
  chroot "${MNTPOINT}" grub-mkimage -O i386-pc -p "(hd0,msdos1)/boot/grub" -o /tmp/core.img biosdisk part_msdos ext2
  dd if="${MNTPOINT}/tmp/core.img" of="${ORIG_TARGET}" conv=notrunc seek=4
  rm -f "${MNTPOINT}/tmp/core.img"

  einfo "Updating grub configuration file."
  if [ -n "$BOOT_APPEND" ] ; then
     sed -i "/GRUB_CMDLINE_LINUX_DEFAULT/ s#\"\$# ${BOOT_APPEND}\"#" "${MNTPOINT}"/etc/default/grub
  fi
  chroot "${MNTPOINT}" update-grub

  case "$RELEASE" in
    lenny|squeeze|wheezy)
      einfo "Adjusting grub.cfg for successful boot sequence."
      sed -i "s;root=[^ ]\+;root=UUID=$TARGET_UUID;" "${MNTPOINT}"/boot/grub/grub.cfg
      ;;
  esac

  umount "${MNTPOINT}"/proc
  umount "${MNTPOINT}"/sys
  umount "${MNTPOINT}"/dev
  umount "${MNTPOINT}"
  kpartx -d "${ORIG_TARGET}" >/dev/null
}
# }}}

# install main chroot {{{
debootstrap_system() {
  if [ "$_opt_nodebootstrap" ]; then
     einfo "Skipping debootstrap as requested."
     return
  fi

  if grep -q "$MNTPOINT" /proc/mounts || [ -n "$DIRECTORY" ] ; then
    :
  else
    eerror "Error: $MNTPOINT not mounted, can not continue."
    eend 1 ; exit 1
  fi

  if [ -n "$ISO" ] ; then
    einfo "Running $DEBOOTSTRAP $DEBOOTSTRAP_OPT for release ${RELEASE}${ARCHINFO} using ${ISO}"
    einfo "Executing: $DEBOOTSTRAP $ARCHCMD $KEYRING $DEBOOTSTRAP_OPT $RELEASE $MNTPOINT $ISO"
    "$DEBOOTSTRAP" $ARCHCMD $KEYRING $DEBOOTSTRAP_OPT "$RELEASE" "$MNTPOINT" "$ISO"
    RC=$?
  else
    einfo "Running $DEBOOTSTRAP $DEBOOTSTRAP_OPT for release ${RELEASE}${ARCHINFO} using ${MIRROR}"
    einfo "Executing: $DEBOOTSTRAP $ARCHCMD $KEYRING $DEBOOTSTRAP_OPT $RELEASE $MNTPOINT $MIRROR"
    "$DEBOOTSTRAP" $ARCHCMD $KEYRING $DEBOOTSTRAP_OPT "$RELEASE" "$MNTPOINT" "$MIRROR"
    RC=$?
  fi

  if [ $RC -ne 0 ] ; then
    if [ -r "$MNTPOINT/debootstrap/debootstrap.log" ] && \
      [ -s "$MNTPOINT/debootstrap/debootstrap.log" ] ; then
      einfo "Presenting last ten lines of debootstrap.log:"
      tail -10 "${MNTPOINT}"/debootstrap/debootstrap.log
      einfo "End of debootstrap.log"
    fi
  fi

  eend $RC
}
# }}}

# prepare chroot via chroot-script {{{
preparechroot() {
  einfo "Preparing chroot system"

  # provide variables to chroot system
  CHROOT_VARIABLES="/var/cache/grml-debootstrap/variables_${SHORT_TARGET}"
  touch "$CHROOT_VARIABLES"
  chmod 600 "$CHROOT_VARIABLES" # make sure nobody except root can read it
  echo "# Configuration of ${PN}"                                                                                   > "$CHROOT_VARIABLES"
  # Resorting to sed(1) for escaping since "VAR='${VAR//\'/\'\\\'\'}'" does not work with all versions of Bash,
  #   e.g. not with 4.2.37(1)-release (a.k.a 4.2+dfsg-0.1+deb7u3) of Debian wheezy
  [ -n "$ARCH" ]                && echo "ARCH='$(sed "s,','\\\\'',g" <<<"${ARCH}")'"                               >> "$CHROOT_VARIABLES"
  [ -n "$BACKPORTREPOS" ]       && echo "BACKPORTREPOS='$(sed "s,','\\\\'',g" <<<"${BACKPORTREPOS}")'"             >> "$CHROOT_VARIABLES"
  [ -n "$CHROOT_SCRIPTS" ]      && echo "CHROOT_SCRIPTS='$(sed "s,','\\\\'',g" <<<"${CHROOT_SCRIPTS}")'"           >> "$CHROOT_VARIABLES"
  [ -n "$CONFFILES" ]           && echo "CONFFILES='$(sed "s,','\\\\'',g" <<<"${CONFFILES}")'"                     >> "$CHROOT_VARIABLES"
  [ -n "$DEBCONF" ]             && echo "DEBCONF='$(sed "s,','\\\\'',g" <<<"${DEBCONF}")'"                         >> "$CHROOT_VARIABLES"
  [ -n "$DEBIAN_FRONTEND" ]     && echo "DEBIAN_FRONTEND='$(sed "s,','\\\\'',g" <<<"${DEBIAN_FRONTEND}")'"         >> "$CHROOT_VARIABLES"
  [ -n "$DEBOOTSTRAP" ]         && echo "DEBOOTSTRAP='$(sed "s,','\\\\'',g" <<<"${DEBOOTSTRAP}")'"                 >> "$CHROOT_VARIABLES"
  [ -n "$DEFAULT_LOCALES" ]     && echo "DEFAULT_LOCALES='$(sed "s,','\\\\'',g" <<<"${DEFAULT_LOCALES}")'"         >> "$CHROOT_VARIABLES"
  [ -n "$DEFAULT_LANGUAGE" ]    && echo "DEFAULT_LANGUAGE='$(sed "s,','\\\\'',g" <<<"${DEFAULT_LANGUAGE}")'"       >> "$CHROOT_VARIABLES"
  [ -n "$EXTRAPACKAGES" ]       && echo "EXTRAPACKAGES='$(sed "s,','\\\\'',g" <<<"${EXTRAPACKAGES}")'"             >> "$CHROOT_VARIABLES"
  [ -n "$FALLBACK_MIRROR" ]     && echo "FALLBACK_MIRROR='$(sed "s,','\\\\'',g" <<<"${FALLBACK_MIRROR}")'"         >> "$CHROOT_VARIABLES"
  [ -n "$FORCE" ]               && echo "FORCE='$(sed "s,','\\\\'',g" <<<"${FORCE}")'"                             >> "$CHROOT_VARIABLES"
  [ -n "$GRMLREPOS" ]           && echo "GRMLREPOS='$(sed "s,','\\\\'',g" <<<"${GRMLREPOS}")'"                     >> "$CHROOT_VARIABLES"
  [ -n "$GRUB" ]                && echo "GRUB='$(sed "s,','\\\\'',g" <<<"${GRUB}")'"                               >> "$CHROOT_VARIABLES"
  [ -n "$HOSTNAME" ]            && echo "HOSTNAME='$(sed "s,','\\\\'',g" <<<"${HOSTNAME}")'"                       >> "$CHROOT_VARIABLES"
  [ -n "$INITRD" ]              && echo "INITRD='$(sed "s,','\\\\'',g" <<<"${INITRD}")'"                           >> "$CHROOT_VARIABLES"
  [ -n "$INSTALL_NOTES" ]       && echo "INSTALL_NOTES='$(sed "s,','\\\\'',g" <<<"${INSTALL_NOTES}")'"             >> "$CHROOT_VARIABLES"
  [ -n "$ISODIR" ]              && echo "ISODIR='$(sed "s,','\\\\'',g" <<<"${ISO}")'"                              >> "$CHROOT_VARIABLES"
  [ -n "$ISO" ]                 && echo "ISO='$(sed "s,','\\\\'',g" <<<"${ISO}")'"                                 >> "$CHROOT_VARIABLES"
  [ -n "$KEEP_SRC_LIST" ]       && echo "KEEP_SRC_LIST='$(sed "s,','\\\\'',g" <<<"${KEEP_SRC_LIST}")'"             >> "$CHROOT_VARIABLES"
  [ -n "$LOCALES" ]             && echo "LOCALES='$(sed "s,','\\\\'',g" <<<"${LOCALES}")'"                         >> "$CHROOT_VARIABLES"
  [ -n "$MIRROR" ]              && echo "MIRROR='$(sed "s,','\\\\'',g" <<<"${MIRROR}")'"                           >> "$CHROOT_VARIABLES"
  [ -n "$MKFS" ]                && echo "MKFS='$(sed "s,','\\\\'',g" <<<"${MKFS}")'"                               >> "$CHROOT_VARIABLES"
  [ -n "$NOPASSWORD" ]          && echo "NOPASSWORD=\"true\""                                                      >> "$CHROOT_VARIABLES"
  [ -n "$NOKERNEL" ]            && echo "NOKERNEL=\"true\""                                                        >> "$CHROOT_VARIABLES"
  [ -n "$PACKAGES" ]            && echo "PACKAGES='$(sed "s,','\\\\'',g" <<<"${PACKAGES}")'"                       >> "$CHROOT_VARIABLES"
  [ -n "$PRE_SCRIPTS" ]         && echo "PRE_SCRIPTS='$(sed "s,','\\\\'',g" <<<"${PRE_SCRIPTS}")'"                 >> "$CHROOT_VARIABLES"
  [ -n "$RECONFIGURE" ]         && echo "RECONFIGURE='$(sed "s,','\\\\'',g" <<<"${RECONFIGURE}")'"                 >> "$CHROOT_VARIABLES"
  [ -n "$RELEASE" ]             && echo "RELEASE='$(sed "s,','\\\\'',g" <<<"${RELEASE}")'"                         >> "$CHROOT_VARIABLES"
  [ -n "$RM_APTCACHE" ]         && echo "RM_APTCACHE='$(sed "s,','\\\\'',g" <<<"${RM_APTCACHE}")'"                 >> "$CHROOT_VARIABLES"
  [ -n "$ROOTPASSWORD" ]        && echo "ROOTPASSWORD='$(sed "s,','\\\\'',g" <<<"${ROOTPASSWORD}")'"               >> "$CHROOT_VARIABLES"
  [ -n "$SCRIPTS" ]             && echo "SCRIPTS='$(sed "s,','\\\\'',g" <<<"${SCRIPTS}")'"                         >> "$CHROOT_VARIABLES"
  [ -n "$SECURE" ]              && echo "SECURE='$(sed "s,','\\\\'',g" <<<"${SECURE}")'"                           >> "$CHROOT_VARIABLES"
  [ -n "$SELECTED_PARTITIONS" ] && echo "SELECTED_PARTITIONS='$(sed "s,','\\\\'',g" <<<"${SELECTED_PARTITIONS}")'" >> "$CHROOT_VARIABLES"
  [ -n "$TARGET" ]              && echo "TARGET='$(sed "s,','\\\\'',g" <<<"${TARGET}")'"                           >> "$CHROOT_VARIABLES"
  [ -n "$UPGRADE_SYSTEM" ]      && echo "UPGRADE_SYSTEM='$(sed "s,','\\\\'',g" <<<"${UPGRADE_SYSTEM}")'"           >> "$CHROOT_VARIABLES"
  [ -n "$TARGET_UUID" ]         && echo "TARGET_UUID='$(sed "s,','\\\\'',g" <<<"${TARGET_UUID}")'"                 >> "$CHROOT_VARIABLES"
  [ -n "$TIMEZONE" ]            && echo "TIMEZONE='$(sed "s,','\\\\'',g" <<<"${TIMEZONE}")'"                       >> "$CHROOT_VARIABLES"
  [ -n "$TUNE2FS" ]             && echo "TUNE2FS='$(sed "s,','\\\\'',g" <<<"${TUNE2FS}")'"                         >> "$CHROOT_VARIABLES"
  [ -n "$VMSIZE" ]              && echo "VMSIZE='$(sed "s,','\\\\'',g" <<<"${VMSIZE}")'"                           >> "$CHROOT_VARIABLES"

  cp $VERBOSE "${CONFFILES}"/chroot-script "${MNTPOINT}"/bin/chroot-script
  chmod 755 "${MNTPOINT}"/bin/chroot-script
  [ -d "$MNTPOINT"/etc/debootstrap/ ] || mkdir "$MNTPOINT"/etc/debootstrap/

  # make sure we have our files for later use via chroot-script
  cp $VERBOSE "${CONFFILES}/config"           "${MNTPOINT}"/etc/debootstrap/
  # make sure we adjust the configuration variables accordingly:
  sed -i "s#RELEASE=.*#RELEASE=\"$RELEASE\"#" "${MNTPOINT}"/etc/debootstrap/config
  sed -i "s#TARGET=.*#TARGET=\"$TARGET\"#"    "${MNTPOINT}"/etc/debootstrap/config
  sed -i "s#GRUB=.*#GRUB=\"$GRUB\"#"          "${MNTPOINT}"/etc/debootstrap/config

  # install notes:
  if [ -n "$INSTALL_NOTES" ] ; then
     [ -r "$INSTALL_NOTES" ] && cp "$INSTALL_NOTES" "${MNTPOINT}"/etc/debootstrap/
  fi

  # package selection:
  cp $VERBOSE "${_opt_packages:-$CONFFILES/packages}" \
    "${MNTPOINT}"/etc/debootstrap/packages

  # debconf preseeding:
  _opt_debconf=${_opt_debconf:-$CONFFILES/debconf-selections}
  [ -f "${_opt_debconf}" ] && [ "$DEBCONF" = 'yes' ] && \
    cp $VERBOSE "${_opt_debconf}" "${MNTPOINT}"/etc/debootstrap/debconf-selections

  # copy scripts that should be executed inside the chroot:
  _opt_chroot_scripts=${_opt_chroot_scripts:-$CONFFILES/chroot-scripts/}
  [ -d "$_opt_chroot_scripts" ] && [ "$CHROOT_SCRIPTS" = 'yes' ] && {
    mkdir -p "${MNTPOINT}"/etc/debootstrap/chroot-scripts
    cp -a $VERBOSE "${_opt_chroot_scripts}"/* "${MNTPOINT}"/etc/debootstrap/chroot-scripts/
  }

  # notice: do NOT use $CHROOT_VARIABLES inside chroot but statically file instead!
  cp $VERBOSE "${CHROOT_VARIABLES}" "${MNTPOINT}"/etc/debootstrap/variables

  cp $VERBOSE -a -L "${CONFFILES}"/extrapackages/ "${MNTPOINT}"/etc/debootstrap/

  # make sure we can access network [relevant for cdebootstrap]
  [ -f "${MNTPOINT}"/etc/resolv.conf ] || cp $VERBOSE /etc/resolv.conf "${MNTPOINT}"/etc/resolv.conf

  # provide system's /etc/hosts to the target:
  if ! [ -f "$MNTPOINT/etc/hosts" ] ; then
     cp $VERBOSE /etc/hosts "${MNTPOINT}"/etc/hosts
  fi

  # setup default locales
  [ -n "$LOCALES" ] && cp $VERBOSE "${CONFFILES}"/locale.gen "${MNTPOINT}"/etc/locale.gen

  # MAKEDEV is just a forking bomb crap, let's do it on our own instead :)
  ( cd "${MNTPOINT}"/dev && tar zxf /etc/debootstrap/devices.tar.gz )

  # copy any existing files to chroot
  [ -d "${CONFFILES}"/bin   ] && cp $VERBOSE -a -L "${CONFFILES}"/bin/*   "${MNTPOINT}"/bin/
  [ -d "${CONFFILES}"/boot  ] && cp $VERBOSE -a -L "${CONFFILES}"/boot/*  "${MNTPOINT}"/boot/
  [ -d "${CONFFILES}"/etc   ] && cp $VERBOSE -a -L "${CONFFILES}"/etc/*   "${MNTPOINT}"/etc/
  [ -d "${CONFFILES}"/sbin  ] && cp $VERBOSE -a -L "${CONFFILES}"/sbin/*  "${MNTPOINT}"/sbin/
  [ -d "${CONFFILES}"/share ] && cp $VERBOSE -a -L "${CONFFILES}"/share/* "${MNTPOINT}"/share/
  [ -d "${CONFFILES}"/usr   ] && cp $VERBOSE -a -L "${CONFFILES}"/usr/*   "${MNTPOINT}"/usr/
  [ -d "${CONFFILES}"/var   ] && cp $VERBOSE -a -L "${CONFFILES}"/var/*   "${MNTPOINT}"/var/

  # network setup
  DEFAULT_INTERFACES="# /etc/network/interfaces - generated by grml-debootstrap

# Include files from /etc/network/interfaces.d when using
# ifupdown v0.7.44 or newer:
#source-directory /etc/network/interfaces.d

auto lo
iface lo inet loopback

allow-hotplug eth0
iface eth0 inet dhcp
"

  if [ -n "$NOINTERFACES" ] ; then
    einfo "Not installing /etc/network/interfaces as requested via --nointerfaces option" ; eend 0
  elif [ -n "$USE_DEFAULT_INTERFACES" ] ; then
    einfo "Installing default /etc/network/interfaces as requested via --defaultinterfaces options."
    echo "$DEFAULT_INTERFACES" > "${MNTPOINT}/etc/network/interfaces"
    eend $?
  elif [ -n "$VIRTUAL" ] ; then
    einfo "Setting up Virtual Machine, installing default /etc/network/interfaces"
    echo "$DEFAULT_INTERFACES" > "${MNTPOINT}/etc/network/interfaces"
    eend $?
  elif [ -r /etc/network/interfaces ] ; then
    einfo "Copying /etc/network/interfaces from host to target system"
    cp $VERBOSE /etc/network/interfaces "${MNTPOINT}/etc/network/interfaces"
    eend $?
  else
    ewarn "Couldn't read /etc/network/interfaces, installing default /etc/network/interfaces"
    echo "$DEFAULT_INTERFACES" > "${MNTPOINT}/etc/network/interfaces"
    eend $?
  fi

  # install config file providing some example entries
  if [ -r /etc/network/interfaces.examples -a ! -r "$MNTPOINT/etc/network/interfaces.examples" ] ; then
     cp /etc/network/interfaces.examples "$MNTPOINT/etc/network/interfaces.examples"
  fi

  eend 0
}
# }}}

# execute all scripts in /etc/debootstrap/pre-scripts/ {{{
execute_pre_scripts() {
   # make sure we have $MNTPOINT available for our scripts
   export MNTPOINT
   if [ -d "$_opt_pre_scripts" ] || [ "$PRE_SCRIPTS" = 'yes' ] ; then
      [ -d "$_opt_pre_scripts" ] && pre_scripts="$_opt_pre_scripts" || pre_scripts="$CONFFILES/pre-scripts/"
      for script in ${pre_scripts}/* ; do
         if [ -x "$script" ] ; then
            einfo "Executing pre-script $script"
            $script ; eend $?
         fi
      done
   fi
}
# }}}

# execute all scripts in /etc/debootstrap/scripts/ {{{
execute_scripts() {
   # make sure we have $MNTPOINT available for our scripts
   export MNTPOINT
   if [ -d "$_opt_scripts" ] || [ "$SCRIPTS" = 'yes' ] ; then
      [ -d "$_opt_scripts" ] && scripts="$_opt_scripts" || scripts="$CONFFILES/scripts/"
      for script in ${scripts}/* ; do
         if [ -x "$script" ] ; then
            einfo "Executing script $script"
            $script ; eend $?
         fi
      done
   fi
}
# }}}

# execute chroot-script {{{
chrootscript() {
  if ! [ -r "$MNTPOINT/bin/chroot-script" ] ; then
    mount_target
  fi

  if ! [ -x "$MNTPOINT/bin/chroot-script" ] ; then
    eerror "Fatal: $MNTPOINT/bin/chroot-script could not be found."
    eend 1
  else
    einfo "Executing chroot-script now"
    mount --bind /dev "$MNTPOINT"/dev
    if [ "$DEBUG" = "true" ] ; then
      chroot "$MNTPOINT" /bin/sh -x /bin/chroot-script ; RC=$?
    else
      chroot "$MNTPOINT" /bin/chroot-script ; RC=$?
    fi
    umount "$MNTPOINT"/dev
    eend $RC
  fi

  # finally get rid of chroot-script again, there's no good reason to
  # keep it on the installed system
  if grep -q GRML_CHROOT_SCRIPT_MARKER "${MNTPOINT}/bin/chroot-script" ; then
    einfo "Removing chroot-script again"
    rm -f "${MNTPOINT}/bin/chroot-script"
    eend $?
  else
    einfo "Keeping chroot-script as string GRML_CHROOT_SCRIPT_MARKER could not be found"
    eend 0
  fi
}
# }}}

# unmount $MNTPOINT {{{
umount_chroot() {

  # display installation notes:
  if [ -n "$INSTALL_NOTES" ] ; then
     [ -r "${MNTPOINT}/${INSTALL_NOTES}" ] && cat "${MNTPOINT}/${INSTALL_NOTES}"
  fi

  if [ -n "$ISODIR" ] ; then
     if grep -q "$ISODIR" /proc/mounts ; then
        einfo "Unmount $MNTPOINT/$ISODIR"
        umount "$MNTPOINT/$ISODIR"
        eend $?
     fi
  fi

  if grep -q "$MNTPOINT" /proc/mounts ; then
     if [ -n "$PARTITION" ] ; then
        einfo "Unmount $MNTPOINT"
        umount "$MNTPOINT"
        eend $?
     fi
  fi
}
# }}}

# execute filesystem check {{{
fscktool() {
 if [ -n "$VIRTUAL" ] ; then
   einfo "Skipping filesystem check because we deploy a virtual machine."
   return 0
 fi

 if [ "$FSCK" = 'yes' ] ; then
   [ -n "$FSCKTOOL" ] || FSCKTOOL="fsck.${MKFS#mkfs.}"
   einfo "Checking filesystem on $TARGET using $FSCKTOOL"
   "$FSCKTOOL" "$TARGET"
   eend $?
 fi
}
# }}}

# now execute all the functions {{{
for i in prepare_vm mkfs tunefs mount_target debootstrap_system \
         preparechroot execute_pre_scripts chrootscript execute_scripts \
         umount_chroot finalize_vm fscktool ; do
    if stage "${i}" ; then
      if "$i" ; then
        stage "${i}" 'done' && rm -f "${STAGES}/${i}"
      else
        bailout 2 "$i"
      fi
    fi
done

cleanup
# }}}

# end dialog of autoinstallation {{{
if [ -n "$AUTOINSTALL" ] ; then
   if dialog --title "${PN}" --pause "Finished execution of ${PN}.
Automatically rebooting in 10 seconds.

Choose Cancel to skip rebooting." 10 60 10 ; then
     noeject noprompt reboot
  fi
else
   einfo "Finished execution of ${PN}. Enjoy your Debian system." ; eend 0
fi
# }}}

## END OF FILE #################################################################
# vim: ai tw=100 expandtab foldmethod=marker shiftwidth=2
