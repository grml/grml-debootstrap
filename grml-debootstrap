#!/bin/bash
# Filename:      grml-debootstrap
# Purpose:       wrapper around debootstrap for installing plain Debian via Grml
# Authors:       grml-team (grml.org), (c) Michael Prokop <mika@grml.org>
# Bug-Reports:   see http://grml.org/bugs/
# License:       This file is licensed under the GPL v2+
################################################################################

# error_handler {{{
[ -n "$REPORT_TRAP_ERR" ] || REPORT_TRAP_ERR='no'
[ -n "$FAIL_TRAP_ERR" ] || FAIL_TRAP_ERR='no'

error_handler() {
   last_exit_code="$?"
   last_bash_command="$BASH_COMMAND"
   if [ "$REPORT_TRAP_ERR" = "yes" ]; then
      echo "Unexpected non-zero exit code $last_exit_code in ${BASH_SOURCE[*]} at line ${BASH_LINENO[*]} detected!
last bash command: $last_bash_command"
   fi
   if [ ! "$FAIL_TRAP_ERR" = "yes" ]; then
      return
   fi
   ## Check if "bailout" function is available.
   ## This is not the case in chroot-script.
   if command -v bailout >/dev/null 2>&1; then
      bailout 1
   else
      echo 'FAIL_TRAP_ERR is set to "yes", exit 1.'
      exit 1
   fi
}

if [ "$REPORT_TRAP_ERR" = "yes" ] || [ "$FAIL_TRAP_ERR" = "yes" ]; then
   set -E
   set -o pipefail
   trap "error_handler" ERR
   export -f "error_handler"
fi
# }}}

# variables {{{
PN="$(basename "$0")"
if [[ -d "$(dirname "$(which "$0")")"/.git ]]; then
  VERSION="$(git describe | sed 's|^v||')"
else
  VERSION="$(dpkg-query --show --showformat='${Version}' "$PN")"
fi
VERSION="${VERSION:-unknown}"
MNTPOINT="/mnt/debootstrap.$$"

# defaults
[ -n "$CHROOT_SCRIPTS" ] || CHROOT_SCRIPTS='yes'
[ -n "$CONFFILES" ] || CONFFILES='/etc/debootstrap'
[ -n "$DEBCONF" ] || DEBCONF='yes'
[ -n "$DEBIAN_FRONTEND" ] || DEBIAN_FRONTEND='noninteractive'
[ -n "$DEBOOTSTRAP" ] || DEBOOTSTRAP='debootstrap'
[ -n "$DEFAULT_LANGUAGE" ] || DEFAULT_LANGUAGE='en_US:en'
[ -n "$DEFAULT_LOCALES" ] || DEFAULT_LOCALES='en_US.UTF-8'
[ -n "$DISK_IDENTIFIER" ] || DISK_IDENTIFIER='26ada0c0-1165-4098-884d-aafd2220c2c6'
[ -n "$EXTRAPACKAGES" ] || EXTRAPACKAGES='yes'
[ -n "$FALLBACK_MIRROR" ] || FALLBACK_MIRROR='http://httpredir.debian.org/debian'
[ -n "$FIXED_DISK_IDENTIFIERS" ] || FIXED_DISK_IDENTIFIERS="no"
[ -n "$FORCE" ] || FORCE=''
[ -n "$HOSTNAME" ] || HOSTNAME='grml'
[ -n "$INITRD" ] || INITRD='yes'
[ -n "$INSTALL_NOTES" ] || INSTALL_NOTES='/etc/debootstrap/install_notes'
[ -n "$LOCALES" ] || LOCALES='yes'
[ -n "$MIRROR" ] || MIRROR="$FALLBACK_MIRROR"
[ -n "$MKFS" ] || MKFS='mkfs.ext4'
[ -n "$MKFS_OPTS" ] || MKFS_OPTS=''
[ -n "$PACKAGES" ] || PACKAGES='yes'
[ -n "$POST_SCRIPTS" ] || POST_SCRIPTS='yes'
[ -n "$PRE_SCRIPTS" ] || PRE_SCRIPTS='yes'
[ -n "$RECONFIGURE" ] || RECONFIGURE='console-data'
[ -n "$RELEASE" ] || RELEASE='stretch'
[ -n "$RM_APTCACHE" ] || RM_APTCACHE='yes'
[ -n "$SCRIPTS" ] || SCRIPTS='no' # deprecated, replaced by POST_SCRIPTS
[ -n "$SECURE" ] || SECURE='yes'
[ -n "$TIMEZONE" ] || TIMEZONE='Europe/Vienna'
[ -n "$TUNE2FS" ] || TUNE2FS='tune2fs -c0 -i0'
[ -n "$UPGRADE_SYSTEM" ] || UPGRADE_SYSTEM='yes'
[ -n "$VMSIZE" ] || VMSIZE="2G"

# inside the chroot system locales might not be available, so use minimum:
export LANG=C
export LC_ALL=C
export LANGUAGE=C

# make sure interactive mode is only executed when
# using an empty configuration file or option --interactive
INTERACTIVE=''
# }}}

# help text {{{
usage() {
  echo "$PN - wrapper around debootstrap for installing Debian

Usage: $PN [options]

Bootstrap options:

  -m, --mirror <URL>     Mirror which should be used for apt-get/aptitude.
  -i, --iso <mnt>        Mountpoint where a Debian ISO is mounted to, for use
                         instead of fetching packages from a mirror.
  -r, --release <name>   Release of new Debian system (default: stretch).
  -t, --target <target>  Target partition (/dev/...) or directory where the
                         system should be installed to.
  -p, --mntpoint <mnt>   Mountpoint used for mounting the target system,
                         has no effect if -t is given and represents a directory.
      --debopt <params>  Extra parameters passed to the debootstrap command.
      --interactive      Use interactive mode (frontend).
      --nodebootstrap    Skip debootstrap, only do configuration to the target.
      --grub <device>    Target for grub installation. Usage example: /dev/sda
      --efi <device>     Target for EFI installation. Usage example: /dev/sda1
      --arch <arch>      Set target architecture, use for installing i386 on amd64.
      --filesystem <fs>  Filesystem that should be used when target is a partition
                         or Virtual Machine (see --vmfile).
      --force            Do not prompt for user acknowledgement.

Options for Virtual Machine deployment:

      --vm               Set up a Virtual Machine on an existing block device
                         instead of plainly installing to a partition or
                         directory. Needs to be combined with --target.
                         Example: --vm --target /dev/mapper/your-vm-disk
      --vmfile           Like --vm, but install into a regular file (created by
                         'qemu-img create -f raw ...') instead.
                         Example: --vmfile --target /mnt/sda1/qemu.img
      --vmsize <size>    Use specified size for size of VM file (default: 2G).
                         Syntax as supported by qemu-img, like: --vmsize 3G

Configuration options:

  -c, --config <file>      Use specified configuration file, defaults to
                             /etc/debootstrap/config
  -d, --confdir <path>     Place of config files for debootstrap, defaults
                             to /etc/debootstrap
      --packages <file>    Install packages defined in specified list file
                             instead of using /etc/debootstrap/packages.
      --nopackages         Skip installation of packages defined in
                             /etc/debootstrap/packages
      --nokernel           Skip installation of default kernel images.
      --nointerfaces       Do not copy /etc/network/interfaces from host system
                           to target system.
                           (This option is automatically enabled when using --vmfile.)
      --defaultinterfaces  Install a default /etc/network/interfaces file (enabling
                           DHCP for eth0) instead of taking over config from host system.
      --debconf <file>     Pre-seed packages using specified pre-seed db file.
      --grmlrepos          Enable Grml's Debian repository (deb.grml.org).
      --backportrepos      Enable Debian's backports repository (backports.debian.org).
      --keep_src_list      Do not overwrite user provided apt sources.list.
      --contrib            Enable 'contrib' in COMPONENTS (defaults to 'main' only).
      --non-free           Enable non-free in COMPONENTS (defaults to 'main' only).
      --hostname <name>    Hostname of Debian system.
      --nopassword         Do not prompt for the root password.
      --password <pwd>     Use specified password as password for user root.
      --bootappend <line>  Add specified appendline to kernel whilst booting.
      --chroot-scripts <d> Execute chroot scripts from specified directory.
      --pre-scripts <dir>  Execute scripts from specified directory (before chroot-scripts).
      --scripts <dir>      Execute scripts from specified directory (after chroot-scripts).
      --remove-configs     Delete grml-debootstrap configuration files from installed system.

Other options:

  -v, --verbose            Increase verbosity.
      --debug              Execute in very verbose way.
  -h, --help               Print this usage information and exit.
  -V, --version            Show summary of options and exit.

Usage examples can be found in the grml-debootstrap manpage.
Send bugreports to the grml-team: bugs (at) grml.org || http://grml.org/bugs/
"
}

if [ "$1" = '-h' ] || [ "$1" = '-help' ] || [ "$1" = "--help" ] ; then
   usage
   echo 'Please notice that this script requires root permissions!'
   exit 0
fi
# }}}

# early helper functions {{{
GOOD='[32;01m'
BAD='[31;01m'
WARN='[33;01m'
NORMAL='[0m'

einfo() {
  einfon "$1\n"
  return 0
}

einfon() {
  [ "${RC_ENDCOL}" != "yes" ] && [ "${LAST_E_CMD}" = "ebegin" ] && echo
  printf " %s*%s $*" "${GOOD}" "${NORMAL}"
  LAST_E_CMD=einfon
  return 0
}

ewarn() {
  printf " %s*%s $*\n" "${WARN}" "${NORMAL}"
  return 0
}

eerror() {
  [ "${RC_ENDCOL}" != "yes" ] && [ "${LAST_E_CMD}" = "ebegin" ] && echo
  printf " %s*%s $*\n" "${BAD}" "${NORMAL}" >&2
  LAST_E_CMD=eerror
  return 0
}

eend() {
  local retval="${1:-0}"
  shift
  if [ "$retval" -gt 0 ]; then
    printf " %s-> Failed (rc=%s)%s\n" "${BAD}" "${retval}" "${NORMAL}"
  fi
  return "$retval"
}

check4root(){
  if [ "$(id -u 2>/dev/null)" != 0 ] ; then
    echo 1>&2 "Error: please run this script with uid 0 (root)." ; return 1
  fi
}

check4progs(){
  local RC=''
  for arg in "$@" ; do
    which "$arg" >/dev/null 2>&1 || RC="$arg"
  done
  if [ -n "$RC" ] ; then
     echo "$RC not installed"
     return 1
  fi
}
# }}}

# helper functions {{{
cleanup() {
  if [ -n "$CHROOT_VARIABLES" ] ; then
    einfo "Removing ${CHROOT_VARIABLES}" ; rm "$CHROOT_VARIABLES" ; eend $?
  fi

  if [ -n "$STAGES" ] ; then
    einfo "Removing ${STAGES}" ; rmdir "$STAGES" ; eend $?
  fi

  # Remove temporary mountpoint again
  if echo "$MNTPOINT" | grep -q '/mnt/debootstrap\.' ; then
    rmdir "$MNTPOINT" 2>/dev/null
  fi

  # make sure $TARGET is not mounted when exiting grml-debootstrap
  if [ -n "$MNTPOINT" ] ; then
    if grep -q "$MNTPOINT" /proc/mounts ; then
      # make sure nothing is left inside chroot so we can unmount it
      for service in ssh mdadm ; do
        if [ -x "${MNTPOINT}/etc/init.d/${service}" ] ; then
          chroot "$MNTPOINT" "/etc/init.d/${service}" stop
        fi
      done

      [ -x "$MNTPOINT"/bin/umount ] && chroot "$MNTPOINT" umount -a >/dev/null 2>&1

      # ugly, but make sure we really don't leave anything (/proc /proc and
      # /dev /dev are intended, trying to work around timing issues, see #657023)
      for ARG in /sys /proc /proc /dev/pts /dev/pts /dev /dev ; do
        [ -x "$MNTPOINT"/bin/umount ] && chroot "$MNTPOINT" umount $ARG >/dev/null 2>&1
        umount "$MNTPOINT"/$ARG >/dev/null 2>&1
      done

      if [ -n "$ISODIR" ] ; then
        [ -d "$MNTPOINT/$ISODIR" ] && umount "$MNTPOINT/$ISODIR" >/dev/null 2>&1
      fi

      if [ -n "$DIRECTORY" ] ; then
        einfo "Not unmounting $MNTPOINT as you requested me to install into a directory of your own choice." ; eend 0
      else
        einfo "Unmounting $MNTPOINT"
        umount "$MNTPOINT"
        eend $?
      fi

      if [ -n "$STAGES" ] ; then
        echo -n "Removing stages directory ${STAGES}: "
        rm -rf "$STAGES" && echo 'done'
      fi

      # remove directory only if we used the default with process id inside the name
      if echo "$MNTPOINT" | grep -q '/mnt/debootstrap\.' ; then
        einfo "Removing directory ${MNTPOINT}"
        rmdir "$MNTPOINT"
        eend $?
      fi
    fi
  fi

  if [ -n "${ORIG_TARGET}" ] ; then
    einfo "Removing loopback mount of file ${ORIG_TARGET}."
    kpartx -d "${ORIG_TARGET}" ; eend $?
  fi
}

# we want to exit smoothly and clean:
bailout(){

  cleanup

  [ -n "$1" ] && EXIT="$1" || EXIT="1"
  [ -n "$2" ] && einfo "Notice: remove $STAGES/$2 to reexecute the stage"

  exit "$EXIT"
}
trap bailout HUP INT QUIT TERM

# we want to execute all the functions only once, simple check for it:
stage() {
  if [ -n "$2" ] ; then
     echo "$2" > "${STAGES}/${1}"
     return 0
  elif grep -q 'done' "${STAGES}/${1}" 2>/dev/null ; then
     ewarn "Notice: stage $1 has been executed already, skipping execution therefore." ; eend 0
     ewarn "  To reexecute it clean up the according directory inside $STAGES" ; eend 0
     return 1
  fi
}
# }}}

# make sure we have what we need {{{
check4progs debootstrap || bailout 1
# }}}

# source main configuration file {{{
if [ -r /etc/debootstrap/config ] ; then
  # shellcheck disable=SC1091
  . /etc/debootstrap/config
fi
# }}}

# cmdline handling {{{
CMDLINE_OPTS=mirror:,iso:,release:,target:,mntpoint:,debopt:,defaultinterfaces,interactive,nodebootstrap,nointerfaces,nokernel,nopackages,filesystem:,config:,confdir:,packages:,chroot-scripts:,scripts:,post-scripts:,pre-scripts:,debconf:,vm,vmfile,vmsize:,keep_src_list,hostname:,password:,nopassword,grmlrepos,backportrepos,bootappend:,grub:,efi:,arch:,insecure,verbose,help,version,force,debug,contrib,non-free,remove-configs

_opt_temp=$(getopt --name grml-debootstrap -o +m:i:r:t:p:c:d:vhV --long \
  $CMDLINE_OPTS -- "$@")

if [ $? != 0 ]; then
  eerror "Try 'grml-debootstrap --help' for more information."; eend 1; exit 1
fi
eval set -- "$_opt_temp"

while :; do
  case "$1" in

  # == Bootstrap options
  --mirror|-m)         # Mirror which should be used for apt-get/aptitude
    shift; _opt_mirror="$1"
    ;;
  --iso|-i)            # Mountpoint where a Debian ISO is mounted to
    shift; _opt_iso="$1"
    ;;
  --release|-r)        # Release of new Debian system
    shift; _opt_release="$1"
    ;;
  --target|-t)         # Target partition (/dev/...) or directory
    shift; _opt_target="$1"
    ;;
  --vm)                # Virtual machine image (no file)
    _opt_vm="T"
    ;;
  --vmfile)            # Virtual machine file
    _opt_vmfile="T"
    ;;
  --vmsize)            # size of Virtual machine file
    shift; _opt_vmsize="$1"
    ;;
  --mntpoint|-p)       # Mountpoint used for mounting the target system
    shift; _opt_mntpoint="$1"
    ;;
  --debopt)            # Extra parameters passed to the debootstrap command
    shift; _opt_debopt="$1"
    ;;
  --filesystem)        # Filesystem that should be used
    shift; _opt_filesystem="$1"
    ;;
  --interactive)       # Use interactive mode (frontend)
    _opt_interactive=T
    ;;
  --nodebootstrap)     # Skip debootstrap, only do configuration to the target
    _opt_nodebootstrap=T
    ;;
  --nopackages)        # Skip installation of packages defined in /etc/debootstrap/packages
    _opt_nopackages=T
    ;;
  --arch)              # Target architecutre
    shift; _opt_arch="$1"
    ;;
  # just for backwards compatibility
  --insecure)
    _opt_insecure=T
    ;;
  #

  # == Configuration options
  --config|-c)         # Use specified configuration file, defaults to /etc/debootstrap
    shift; _opt_config="$1"
    ;;
  --confdir|-d)        # Place of config files for debootstrap, defaults to /etc/debootstrap
    shift; _opt_confdir="$1"
    ;;
  --packages)          # Install packages defined in specified file
    shift; _opt_packages="$1"
    _opt_packages_set=T
    ;;
  --debconf)           # Pre-seed packages using specified file
    shift; _opt_debconf="$1"
    _opt_debconf_set=T
    ;;
  --pre-scripts)       # Execute scripts from specified directory (before chroot-scripts).
    shift; _opt_pre_scripts="$1"
    _opt_pre_scripts_set=T
    ;;
  --scripts)           # Execute scripts from specified directory [NOTE: deprecated, replaced via --post-scripts]
    shift; _opt_scripts="$1"
    _opt_scripts_set=T
    ;;
  --post-scripts)       # Execute scripts from specified directory
    shift; _opt_post_scripts="$1"
    _opt_post_scripts_set=T
    ;;
  --chroot-scripts)   # Execute chroot scripts from specified directory
    shift; _opt_chroot_scripts="$1"
    _opt_chroot_scripts_set=T
    ;;
  --keep_src_list)     # Do not overwrite user provided apt sources.list
    _opt_keep_src_list=T
    ;;
  --hostname)          # Hostname of Debian system
    shift; _opt_hostname="$1"
    ;;
  --password)          # Use specified password as password for user root
    shift; _opt_password="$1"
    ;;
  --defaultinterfaces) # Install default /etc/network/interfaces
    _opt_defaultinterfaces=T
    ;;
  --nointerfaces)      # Skip installation of /etc/network/interfaces
    _opt_nointerfaces=T
    ;;
  --nokernel)          # Skip installation of default kernel images
    _opt_nokernel=T
    ;;
  --nopassword)        # Skip password dialog
    _opt_nopassword=T
    ;;
  --grmlrepos)         # Enable Grml repository
    _opt_grmlrepos=T
    ;;
  --backportrepos)     # Enable Debian backports repository
    _opt_backportrepos=T
    ;;
  --bootappend)        # Add specified appendline to kernel whilst booting
    shift; _opt_bootappend="$1"
    ;;
  --grub)              # Target for grub installation. Use grub syntax for specifying
    shift; _opt_grub="$1"
    ;;
  --efi)               # Target for EFI boot installation
    shift; _opt_efi="$1"
    ;;
  --contrib)           # Add 'contrib' to list of components
    _opt_contrib=T
    ;;
  --non-free)          # Add 'non-free' to list of components
    _opt_non_free=T
    ;;
  --remove-configs)    # Drop config files from installed system
    _opt_remove_configs=T
    ;;

  # == Other options
  --verbose|-v)        # Increase verbosity
    if [ "$_opt_verbose" ]; then _opt_verbose=`expr $_opt_verbose + 1`
    else _opt_verbose=1; fi
    ;;
  --debug)             # Execute in debug mode
    _opt_debug=T
    ;;
  --help|-h)           # Print usage information and exit
    _opt_help=T
    ;;
  --version|-V)        # Show version information and exit
    _opt_version=T
    ;;
  --force)             # Do not prompt for user input
    _opt_force=T
    ;;
  --)
    shift; break
    ;;
  *)
    eerror "Internal getopt error!"; eend 1 ; exit 1
    ;;
  esac
  shift
done

# == business-logic of command line parameter-processing

# source configuration file in <confdir> if supplied. {{{
[ "$_opt_confdir" ] && {
  CONFFILES=$_opt_confdir
  einfo "Using config files under $CONFFILES/."
  if ! [ -r "$CONFFILES/config" ] ; then
    eerror "Error: config file $CONFFILES/config not found."; eend 1; bailout 1
  fi
  # shellcheck disable=SC1091 source=config
  if ! . "$CONFFILES/config" ; then
    eerror "Error reading config file $CONFFILES/config" ; eend 1 ; bailout 1
  fi
  # restore the command line parameter value
  CONFFILES=$_opt_confdir
}
# }}}

[ "$_opt_mirror" ]              && MIRROR=$_opt_mirror
[ "$_opt_iso" ]                 && ISO=$_opt_iso
[ "$_opt_release" ]             && RELEASE=$_opt_release
[ "$_opt_target" ]              && TARGET=$_opt_target
[ "$_opt_vm" ]                  && VIRTUAL=1
[ "$_opt_vmfile" ]              && VMFILE=1 && VIRTUAL=1
[ "$_opt_vmsize" ]              && VMSIZE=$_opt_vmsize
[ "$_opt_mntpoint" ]            && MNTPOINT=$_opt_mntpoint
[ "$_opt_debopt" ]              && DEBOOTSTRAP_OPT=$_opt_debopt
[ "$_opt_interactive" ]         && INTERACTIVE=1
[ "$_opt_config" ]              && CONFIGFILE=$_opt_config
[ "$_opt_filesystem" ]          && MKFS="mkfs.$_opt_filesystem"
[ "$_opt_packages_set" ]        && PACKAGES='yes'
[ "$_opt_nopackages" ]          && PACKAGES=''
[ "$_opt_debconf_set" ]         && DEBCONF='yes'
[ "$_opt_post_scripts_set" ]    && POST_SCRIPTS='yes'
[ "$_opt_pre_scripts_set" ]     && PRE_SCRIPTS='yes'
[ "$_opt_chroot_scripts_set" ]  && CHROOT_SCRIPTS='yes'
[ "$_opt_keep_src_list" ]       && KEEP_SRC_LIST='yes'
[ "$_opt_grmlrepos" ]           && GRMLREPOS='yes'
[ "$_opt_backportrepos" ]       && BACKPORTREPOS='yes'
[ "$_opt_hostname" ]            && HOSTNAME=$_opt_hostname
[ "$_opt_password" ]            && ROOTPASSWORD=$_opt_password
[ "$_opt_nopassword" ]          && NOPASSWORD='yes'
[ "$_opt_defaultinterfaces" ]   && USE_DEFAULT_INTERFACES="true"
[ "$_opt_nointerfaces" ]        && NOINTERFACES="true"
[ "$_opt_nokernel" ]            && NOKERNEL="true"
[ "$_opt_bootappend" ]          && BOOT_APPEND=$_opt_bootappend
[ "$_opt_grub" ]                && GRUB=$_opt_grub
[ "$_opt_efi" ]                 && EFI=$_opt_efi
[ "$_opt_arch" ]                && ARCH=$_opt_arch
[ "$_opt_insecure" ]            && echo "Warning: --insecure is deprecated, continuing anyway."
[ "$_opt_force" ]               && FORCE=$_opt_force
[ "$_opt_verbose" ]             && VERBOSE="-v"
[ "$_opt_debug" ]               && DEBUG="true"
[ "$_opt_remove_configs" ]      && REMOVE_CONFIGS="yes"

# make sure main is always included
[ -z "$COMPONENTS" ]            && COMPONENTS="main"
[ "$_opt_contrib" ]             && COMPONENTS="$COMPONENTS contrib"
[ "$_opt_non_free" ]            && COMPONENTS="$COMPONENTS non-free"

# command line option checks
if [ "$_opt_scripts_set" ] ; then
  ewarn "Deprecation NOTE: --scripts option is deprecated, please switch to --post-scripts instead."
  SCRIPTS='yes' # deprecated since grml-debootstrap >=0.71
fi

if [ "$_opt_grub" ] && [ "$_opt_vmfile" ] ; then
  eerror "The --grub option is incompatible with --vmfile, please drop it from your command line."
  eerror "The --grub option is unneeded as GRUB will be installed automatically."
  eend 1
  bailout 1
fi


if [ "$DEBUG" = "true" ] ; then
  set -x
fi

[ "$_opt_help" ] && {
  usage ; eend 0
  eend 0
  exit 0
}

[ "$_opt_version" ] && {
  einfo "$PN - version $VERSION"
  einfo "Send bug reports to bugs@grml.org or http://grml.org/bugs/"
  eend 0
  exit 0
}
# }}}

# check for root permissions {{{
if ! check4root ; then
   echo "For usage instructions please execute '$PN --help'."
   bailout 1
fi
# }}}

# make sure we have what we need {{{
if [ -n "$VIRTUAL" ] ; then
  check4progs kpartx parted qemu-img || bailout 1
fi
# }}}

# source specified configuration file {{{
if [ -n "$CONFIGFILE" ] ; then
  einfo "Reading specified config file $CONFIGFILE."
  # shellcheck disable=SC1091 source=config
  if ! . "$CONFIGFILE" ; then
    eerror "Error reading config file $CONFIGFILE" ; eend 1 ; bailout 1
  fi
fi
# }}}

# backwards compatibility checks {{{
if [ -n "$GROOT" ] ; then
   eerror "Error: you seem to have \$GROOT configured."
   eerror "This variable is no longer supported, please visit the"
   eerror "grml-debootstrap documentation for details."
   eend 1
   bailout 1
fi

if echo "$GRUB" | grep -q '^hd' ; then
   eerror "Error: this syntax for the grub configuration variable is no longer supported."
   eerror "Please do not use hd... any longer but /dev/sdX instead."
   eend 1
   bailout 1
fi
# }}}

# welcome screen {{{
welcome_dialog()
{
   dialog --title "$PN" --yesno "Welcome to the interactive configuration of ${PN}.
Do you want to continue installing Debian using this frontend?" 0 0 || bailout 0
}
# }}}

# ask for target {{{
prompt_for_target()
{
  AVAILABLE_PARTITIONS=$(LANG=C fdisk -l 2>/dev/null | \
               sed 's/*//' | \
               grep -v 'Extended$' | \
               gawk -v num=0 -v ORS=' ' '/^\/dev\// {print $1}'; ls /dev/md[0-9]* 2>/dev/null || true);

  if [ -z "$AVAILABLE_PARTITIONS" ] ; then
     dialog --title "$PN" --trim \
     --msgbox "Sorry, no partitions found. Please configure your
     harddisks (see /proc/partitions) using a tool like fdisk,
     cfdisk, gpart, gparted,..." 0 0
     bailout 1
  fi

  PARTITION_LIST=$(for i in $AVAILABLE_PARTITIONS ; do
                     fs="$(blkid -s TYPE -o value "$i" 2>/dev/null)"
                     [ -n "$fs" ] || fs='[no_filesystem_yet]'
                     echo "$i" "$fs"
                     unset fs
                   done)

  # shellcheck disable=SC2086
  TARGET=$(dialog --title "$PN" --single-quoted --stdout \
         --menu "Please select the target partition:" 0 0 0 \
         $PARTITION_LIST)
  [ $? -eq 0 ] || bailout 1
}
# }}}

# ask for bootmanager {{{
prompt_for_bootmanager()
{
  ADDITIONAL_PARAMS=""

  if echo "$TARGET" | grep -q "/dev/md" ; then
     MBRPART="all disks of Software RAID $TARGET"
  else
     # figure out whole disk device
     found=
     for device in /dev/disk/by-id/*
     do
        [ "$(readlink -f "$device")" = "${TARGET}" ] || continue
        found=1
        break
     done
     # shellcheck disable=SC2001
     [ -n "$found" ] && MBRDISK=$(echo "${device}" | sed -e 's/-part[0-9][0-9]*$//')
     if [ -e "$MBRDISK" ]; then
        MBRDISK=$(readlink -f "$MBRDISK")
     else
        # fall back to old behaviour
        # shellcheck disable=SC2001
        MBRDISK=$(echo "${TARGET}" | sed -e 's/[0-9][0-9]*$//')
     fi

     MBRPART="MBR of $MBRDISK"
  fi

  for device in cciss/c0d0 sda hda; do
    if [ "/dev/$device" != "${MBRDISK}" ]; then
      grep -q $device /proc/partitions && \
      ADDITIONAL_PARAMS="$ADDITIONAL_PARAMS:$device:install bootmanager grub into MBR of /dev/$device"
    fi
  done
  ADDITIONAL_PARAMS=${ADDITIONAL_PARAMS#:}

  OIFS="$IFS"; IFS=:

  # shellcheck disable=SC2086
  GETMBR=$(dialog --stdout --title "$PN" --default-item mbr \
          --menu "Where do you want to install the bootmanager grub?" 0 0 0 \
            mbr       "install bootmanager into $MBRPART" \
            nowhere   "do not install bootmanager at all" \
          ${ADDITIONAL_PARAMS})
  [ $? -eq 0 ] || bailout 3
  IFS="$OIFS"

  case "$GETMBR" in
    mbr)
      # /dev/md0: has to be installed in MBR of /dev/md0 and not in /dev/md:
      if echo "$TARGET" | grep -q "/dev/md" ; then
        GRUB="$TARGET"
      else
        GRUB="$MBRDISK"
      fi
      ;;
    hda)
      GRUB="/dev/hda"
      ;;
    sda)
      GRUB="/dev/sda"
      ;;
    nowhere)
      GRUB=''
      ;;
  esac
}
# }}}

# ask for Debian release {{{
prompt_for_release()
{
  [ -n "$RELEASE" ] && DEFAULT_RELEASE="$RELEASE" || DEFAULT_RELEASE='stretch'
  RELEASE="$(dialog --stdout --title "${PN}" --default-item $DEFAULT_RELEASE --menu \
            "Please enter the Debian release you would like to use for installation:" \
            0 50 5 \
            lenny    Debian/5.0 \
            squeeze  Debian/6.0 \
            wheezy   Debian/7.0 \
            jessie   Debian/8.0 \
            stretch  Debian/9.0 \
            sid      Debian/unstable)"
  [ $? -eq 0 ] || bailout
}
# }}}

# ask for hostname {{{
prompt_for_hostname()
{
  HOSTNAME="$(dialog --stdout --title "${PN}" --inputbox \
            "Please enter the hostname you would like to use for installation:" \
            0 0 "$HOSTNAME")"
  [ $? -eq 0 ] || bailout
}
# }}}

# ask for password {{{
prompt_for_password()
{
  if [ "$_opt_nopassword" ] ; then
    einfo "Skip asking for root password as requested."
    return 0
  fi

  ROOTPW1='PW1'
  ROOTPW2='PW2'
  while [ "$ROOTPW1" != "$ROOTPW2" ]; do
    ROOTPW1=$(dialog --insecure --stdout --title "${PN}" --passwordbox \
    "Please enter the password for the root account:" 10 60)
    [ $? -eq 0 ] || bailout

    ROOTPW2=$(dialog --insecure --stdout --title "${PN}" --passwordbox \
    "Please enter the password for the root account again for \
    confirmation:" 10 60)
    [ $? -eq 0 ] || bailout

    if [ "$ROOTPW1" != "$ROOTPW2" ]; then
      dialog --stdout --title "${PN}" --ok-label \
        "Retry" --msgbox "Passwords do not match!" 10 60
    fi
  done
  ROOTPASSWORD="$ROOTPW1"
}
# }}}

# ask for Debian mirror {{{
prompt_for_mirror()
{
  [ -n "$ISO" ] && DEFAULT_MIRROR='local' || DEFAULT_MIRROR='net'

  CHOOSE_MIRROR=$(dialog --stdout --title "$PN" --default-item $DEFAULT_MIRROR \
          --menu "Where do you want to install from?" 0 0 0 \
            net   "install via network (downloading from mirror)" \
            local "install from local directory/mirror"
          )
  [ $? -eq 0 ] || bailout

  if [ "$CHOOSE_MIRROR" = 'net' ] ; then
     [ -n "$MIRROR" ] || MIRROR='http://httpredir.debian.org/debian'
     MIRROR="$(dialog --stdout --title "${PN}" --inputbox \
               "Please enter Debian mirror you would like to use for installing packages." \
               0 0 $MIRROR)"
     [ $? -eq 0 ] || bailout
  else # CHOOSE_MIRROR == local
     [ -n "$ISO" ] || ISO='/mnt/mirror'
     ISO="$(dialog --stdout --title "${PN}" --inputbox \
               "Please enter directory name you would like to use for installing packages." \
               0 0 $ISO)"
     [ $? -eq 0 ] || bailout
  fi
}
# }}}

# software raid setup {{{
config_swraid_setup()
{
TMPFILE=$(mktemp)

# Currently we support only raid1:
RAIDLEVEL='raid1'

MD_LIST=$(for i in $(seq 0 9) ; do
            awk '{print $4}' /proc/partitions | grep -q "md$i" || \
            echo "/dev/md$i /dev/md$i"
          done)

# shellcheck disable=SC2086
TARGET=$(dialog --stdout --title "$PN" --default-item /dev/md0 \
--menu "Which device do you want to use for ${RAIDLEVEL}?

Notice: activated devices will not be listed for security reasons. Anyway, please make sure the selected device is not in use already!" 0 0 0 \
$MD_LIST)
[ $? -eq 0 ] || bailout 20

AVAILABLE_PARTITIONS=$(LANG=C fdisk -l 2>/dev/null | \
             sed 's/*//' | \
             grep -v 'Extended$' | \
             gawk -v num=0 -v ORS=' ' '/^\/dev\// {print $1}')
[ -n "$AVAILABLE_PARTITIONS" ] || echo "Fatal error: no partitions available?"
PARTITION_LIST=$(for i in $AVAILABLE_PARTITIONS ; do
                     echo "$i $(blkid -s TYPE -o value "$i" 2>/dev/null || echo '[no_filesystem_yet]') off"
                 done)

# shellcheck disable=SC2086
dialog --title "$PN" --separate-output \
       --checklist "Please select the partitions you would like to use for your $RAIDLEVEL on ${TARGET}:" 0 0 0 \
       $PARTITION_LIST 2>"$TMPFILE"
[ $? -eq 0 ] || bailout
SELECTED_PARTITIONS="$(cat "$TMPFILE")"

NUM_PARTITIONS=0
while IFS= read -r i; do
  NUM_PARTITIONS=$(( NUM_PARTITIONS + 1 ))
done < "$TMPFILE"

# force metadata version 0.90 for lenny so old grub can boot from this array.
METADATA_VERSION=""
if [ "$RELEASE" = "lenny" ]; then
   METADATA_VERSION="-e0"
fi

ERRORFILE=$(mktemp)
# shellcheck disable=SC2086
yes | mdadm --create "${TARGET}" --level="${RAIDLEVEL}" \
      --raid-devices="${NUM_PARTITIONS}" ${METADATA_VERSION} ${SELECTED_PARTITIONS} >/dev/null 2>$ERRORFILE
RC=$?
if [ "$RC" = 0 ] ; then
   dialog --title "$PN" --msgbox \
   "Creating $TARGET was successful." 0 0
   rm -f "$TMPFILE" "$ERRORFILE"
else
   dialog --title "$PN" --msgbox \
   "There was an error setting up $TARGET:

$(cat "$ERRORFILE")

Exiting." 0 0
   rm -f "$TMPFILE" "$ERRORFILE"
   bailout 1
fi

}

prompt_for_swraid()
{
if dialog --stdout --title "$PN" \
          --defaultno --yesno "Do you want to configure Software RAID?

Please notice that only RAID level 1 is supported by ${PN} currently. Configuration will take place using mdadm." 0 0 ; then
  config_swraid_setup
fi
}
# }}}

# user should recheck his configuration {{{
# support full automatic installation:
checkforrun() {
   dialog --timeout 10 --title "$PN" \
          --yesno "Do you want to stop at this stage?

Notice: you are running ${PN} in non-interactive mode.
${PN} will install Debian ${RELEASE} on ${TARGET}.
Last chance to quit. Timeout of 10 seconds running....

Do you want to stop now?" 0 0 2>/dev/null
}
# }}}

# format efi partition {{{
format_efi_partition() {
  if [ -z "$EFI" ] ; then
    return 0
  fi

  if ! [ -b "$EFI" ] ; then
    eerror "Specified efi argument [$EFI] not a valid block device."
    bailout 1
  fi

  if fsck.vfat -bn "$EFI" >/dev/null; then
    einfo "EFI partition $EFI seems to have a FAT filesystem, not modifying." ; eend 0
  else
    einfo "EFI partition $EFI doesn't seem to be formatted, creating filesystem."
    mkfs.fat -F32 -n "EFI System Partition" "$EFI"
    RC=$?
    if [ $RC -eq 0 ] ; then
      eend 0
    else
      eerror "Error while creating filesystem on ${EFI}."
      eend 1
      bailout 1
    fi
  fi
}
# }}}

# check for EFI support or try to enable it {{{
efi_support() {
  if lsmod | grep -q efivars ; then
    einfo "EFI support detected." ; eend 0
    return 0
  fi

  if modprobe efivars &>/dev/null ; then
    einfo "EFI support enabled now." ; eend 0
    return 0
  fi

  return 1
}
# }}}

# make sure the user is aware of the used configuration {{{
checkconfiguration()
{

if efi_support ; then
  if [ -z "$_opt_efi" ] ; then
    ewarn "EFI support detected but no --efi option given, please consider enabling it." ; eend 0
  fi
else
  if [ -n "$_opt_efi" ] ; then
     eerror "EFI option used but no EFI support detected." ; eend 0
     bailout 1
  fi
fi

if [ -n "$AUTOINSTALL" ] ; then
   if checkforrun ; then
      eerror "Exiting as requested" ; eend 0
      bailout 1
   fi
elif [ -n "$INTERACTIVE" ] ; then

   INFOTEXT="Please recheck configuration before execution:
   "
   [ -n "$TARGET" ]  && INFOTEXT="$INFOTEXT
   Target:          $TARGET"
   [ -n "$GRUB" ]    && INFOTEXT="$INFOTEXT
   Install grub:    $GRUB"
   [ -n "$EFI" ]    && INFOTEXT="$INFOTEXT
   Install efi:     $EFI"
   [ -n "$RELEASE" ] && INFOTEXT="$INFOTEXT
   Using release:   $RELEASE"
   [ -n "$HOSTNAME" ] && INFOTEXT="$INFOTEXT
   Using hostname:  $HOSTNAME"
   [ -n "$MIRROR" ]  && INFOTEXT="$INFOTEXT
   Using mirror:    $MIRROR"
   [ -n "$ISO" ]  && INFOTEXT="$INFOTEXT
   Using ISO:       $ISO"
   [ -n "$ARCH" ]  && INFOTEXT="$INFOTEXT
   Using arch:      $ARCH"
   [ -n "$CONFFILES" ] && INFOTEXT="$INFOTEXT
   Config files:    $CONFFILES"

   INFOTEXT="$INFOTEXT

Is this ok for you? Notice: selecting 'No' will exit ${PN}."

   dialog --title "$PN" --no-collapse \
          --yesno "$INFOTEXT" 0 0
   [ $? -eq 0 ] || bailout 0

else # if not running automatic installation display configuration and prompt for execution:
   einfo "$PN [${VERSION}] - Please recheck configuration before execution:"
   echo
   echo "   Target:          $TARGET"

   # do not display if MNTPOINT is the default one
   case "$MNTPOINT" in /mnt/debootstrap*) ;; *) echo "   Mount point:     $MNTPOINT" ;; esac

   if [ -n "$VIRTUAL" ] ; then
      echo "   Install grub:    yes"
   else
     [ -n "$GRUB" ]     && echo "   Install grub:    $GRUB" || echo "   Install grub:    no"
     [ -n "$EFI" ]      && echo "   Install efi:     $EFI"  || echo "   Install efi:     no"
   fi

   [ -n "$RELEASE" ]   && echo "   Using release:   $RELEASE"
   [ -n "$HOSTNAME" ]  && echo "   Using hostname:  $HOSTNAME"
   [ -n "$MIRROR" ]    && echo "   Using mirror:    $MIRROR"
   [ -n "$ISO" ]       && echo "   Using ISO:       $ISO"
   [ -n "$ARCH" ]      && echo "   Using arch:      $ARCH"
   [ -n "$CONFFILES" ] && echo "   Config files:    $CONFFILES"
   if [ -n "$VIRTUAL" ] ; then
      echo "   Deploying as Virtual Machine."
      if [ -n "$VMSIZE" ] && [ -n "$VMFILE" ]; then
         echo "   Using Virtual Disk file with size of ${VMSIZE}."
      fi
   fi

   if [ ! -t 0 ] && [ -z "$ROOTPASSWORD" ] && [ -z "$NOPASSWORD" ] ; then
      echo
      echo "   You do not have a TTY allocated, your password will be shown in"
      echo "   plaintext on the terminal! If you are using SSH, try its -t option!"
   fi

   echo
   echo "   Important! Continuing will delete all data from ${TARGET}!"

   if [ -n "$FORCE" ] ; then
     einfo "Skip user acknowledgement as requested via --force option."
   else
     echo
     einfon "Is this ok for you? [y/N] "
     read -r a
     if ! [ "$a" = 'y' ] || [ "$a" = 'Y' ] ; then
        eerror "Exiting as requested." ; eend 1
        bailout 1
     fi
   fi
fi
}
# }}}

# interactive mode {{{
interactive_mode()
{
  check4progs dialog || bailout 1

  welcome_dialog

  prompt_for_release

  prompt_for_swraid

  prompt_for_target

  prompt_for_bootmanager

  prompt_for_hostname

  prompt_for_password

  prompt_for_mirror
}

# run interactive mode if we didn't get the according configuration yet
if [ -z "$TARGET" ] || [ -n "$INTERACTIVE" ] ; then
   # only target might be unset, so make sure the INTERACTIVE flag is set as well
   INTERACTIVE=1
   interactive_mode
fi
# }}}

# architecture setup {{{
if [ -n "$ARCH" ] ; then
   ARCHCMD="--arch $ARCH"
   ARCHINFO=" (${ARCH})"
else
   ARCH="$(dpkg --print-architecture)"
   ARCHCMD="--arch $ARCH"
   ARCHINFO=" (${ARCH})"
fi
# }}}

# It is not possible to build amd64 on i686. {{{
CURRENT_ARCH="$(uname -m)"
if [ "$CURRENT_ARCH" != "x86_64" ] ; then
   if [ "$ARCH" = "amd64" ] ; then
      eerror "It is not possible to build amd64 on $CURRENT_ARCH. Consider installing and booting the 'linux-image-amd64' kernel or using '--arch i386' instead." ; eend 1
      bailout 1
   fi
fi
# }}}

# Support for generic release codenames is unavailable. {{{
if [ "$RELEASE" = "stable" ] || [ "$RELEASE" = "testing" ] ; then
   eerror "Generic release codenames (stable, testing) are unsupported. \
Please use specific codenames such as lenny, squeeze, wheezy, jessie or stretch." ; eend 1
   bailout 1
fi
# }}}

checkconfiguration

# finally make sure at least $TARGET is set [the partition for the new system] {{{
if [ -n "$TARGET" ] ; then
   SHORT_TARGET="${TARGET##*/}"
else
   eerror "Please adjust $CONFFILES/config or..."
   eerror "... use the interactive version for configuration before running ${0}" ; eend 1
   bailout 1
fi
# }}}

# stages setup {{{
if [ -z "$STAGES" ] ; then
   STAGES="/var/cache/grml-debootstrap/stages_${SHORT_TARGET}"
   [ -d "$STAGES" ] || mkdir -p "$STAGES"
fi

if [ -r "$STAGES"/grml-debootstrap ] ; then
   if grep -q 'done' "${STAGES}/grml-debootstrap" ; then
      eerror "Error: grml-debootstrap has been executed already, won't continue therefore."
      eerror "If you want to re-execute grml-debootstrap just manually remove ${STAGES}" ; eend 1
   fi
fi
# }}}

# partition handling {{{
PARTITION=''
DIRECTORY=''

set_target_directory(){
    # assume we are installing into a directory, don't run mkfs and grub related stuff therefore
    DIRECTORY=1
    MNTPOINT="$TARGET"
    MKFS=''
    TUNE2FS=''
    FSCK=''
    # make sure we normalise the path to an absolute directory name so something like:
    #  mkdir -p foo/a bar/a; (cd foo; grml-debootstrap -t a)&; (cd bar; grml-debootstrap -t a)&; wait
    # works
    TARGET="$(readlink -f "$TARGET")"
}

if [ -b "$TARGET" ] || [ -n "$VIRTUAL" ] ; then
    PARTITION=1
else
    set_target_directory
fi
# }}}

# make sure we have the right syntax when using an iso image {{{
if [ -n "$ISO" ] ; then
   case $ISO in
      file*) # do nothing
      ;;
      *)
      ISO=file:$ISO
      ;;
   esac
fi
ISODIR=${ISO##file:}
ISODIR=${ISODIR%%/}
# }}}

# Debian ISOs do not contain signed Release files {{{
if [ -n "$ISO" ] ; then
    DEBOOTSTRAP_OPT="$DEBOOTSTRAP_OPT --no-check-gpg"
fi
# }}}

# create filesystem {{{
mkfs() {
  if [ -n "$DIRECTORY" ] ; then
     einfo "Running grml-debootstrap on a directory, skipping mkfs stage."
     return 0
  fi

  if grep -q "$TARGET" /proc/mounts ; then
    eerror "$TARGET already mounted, exiting to avoid possible damage. (Manually unmount $TARGET)" ; eend 1
    bailout 1
  fi

  # mkfs.ext* might prompt with "/dev/sdX# contains a ext* file system
  # created on ... Proceed anyway? (y,n)" which we want to skip in force mode
  if [ -n "$MKFS" ] && [ -n "$FORCE" ] ; then
    case "$MKFS" in
      mkfs.ext*)
        einfo "Enabling force option (-F) for mkfs.ext* tool as requested via --force switch."
        MKFS_OPTS="$MKFS_OPTS -F"
        eend 0

        ;;
    esac
  fi

  # starting with e2fsprogs 1.43~WIP.2015.05.18-1 mkfs.ext4 enables the metadata_csum feature
  # by default, which requires a recent version of tune2fs on the target system then,
  # so disable this feature for older Debian releases where it's known to be unsupported
  if [ -n "$MKFS" ] && [ "$MKFS" = "mkfs.ext4" ] ; then
    case "$RELEASE" in
      lenny|squeeze|wheezy|jessie)
        # assume a more recent version if we can't identify the version via dpkg-query
        local e2fsprogs_version
        e2fsprogs_version="$(dpkg-query --show --showformat='${Version}' e2fsprogs 2>/dev/null || echo 1.44)"
        if [ -n "$e2fsprogs_version" ] && dpkg --compare-versions "$e2fsprogs_version" ge '1.43~WIP.2015.05.18-1' ; then
          einfo "Disabling metadata_csum feature for $MKFS as $RELEASE doesn't support it."
          MKFS_OPTS="$MKFS_OPTS -O ^metadata_csum"
          eend 0
        fi
        ;;
    esac
  fi

  if [ -n "$MKFS" ] ; then
    einfo "Running $MKFS $MKFS_OPTS on $TARGET"
    # shellcheck disable=SC2086
    "$MKFS" $MKFS_OPTS "$TARGET" ; RC=$?

    if [ "$FIXED_DISK_IDENTIFIERS" = "yes" ] ; then
      if ! echo "$MKFS" | grep -q "mkfs.ext" ; then
        eerror "Not changing disk uuid for $TARGET because $MKFS doesn't seem to match for ext{2,3,4} file system"
        eend 1
        bailout 1
      else
        einfo "Changing disk uuid for $TARGET to fixed (non-random) value $DISK_IDENTIFIER using tune2fs"
        tune2fs "$TARGET" -U "$DISK_IDENTIFIER"
        eend $?
      fi
    fi

    # make sure /dev/disk/by-uuid/... is up2date, otherwise grub
    # will fail to detect the uuid in the chroot
    if [ -n "$VIRTUAL" ] ; then
      einfo "Virtual environment doesn't require blockdev --rereadpt, skipping therefore"
    elif echo "$TARGET" | grep -q "/dev/md" ; then
      blockdev --rereadpt "${TARGET}"
    else
      # if we deploy to /dev/sdX# then let's see if /dev/sdX exists
      local main_device="${TARGET%%[0-9]*}"
      # sanity check to not try to e.g. access /dev/loop if we get /dev/loop0
      if [ -f "/sys/block/$(basename "${main_device}")/$(basename "${TARGET}")/dev" ] ; then
        blockdev --rereadpt "$main_device"
      else
        einfo "No underlying block device for $TARGET identified, skipping blockdev --rereadpt."
      fi
    fi
    # give the system 2 seconds, otherwise we might run into
    # race conditions :-/
    sleep 2

    eend $RC
  fi
}
# }}}

# retrieve ID_FS_UUID {{{
identify_target_uuid() {
  local device="$1"

  if ! [ -b "$device" ] ; then
    return 1
  fi

  eval "$(blkid -o udev "$1" 2>/dev/null)"

  if [ -n "$ID_FS_UUID" ] ; then
    echo "$ID_FS_UUID"
  else
    return 1
  fi
}
# }}}

# identify TARGET_UUID {{{
mountpoint_to_blockdevice() {
  TARGET_UUID=''

  TARGET_UUID=$(identify_target_uuid "$TARGET" 2>/dev/null || true)
  if [ -n "$TARGET_UUID" ] ; then
    einfo "Identified UUID $TARGET_UUID for $TARGET"
    return 0
  fi

  # $TARGET might be a mountpoint and not a blockdevice, search for according entry
  for file in /sys/block/*/*/dev ; do
    if grep -q "^$(mountpoint -d "${TARGET}")$" "$file" ; then
      local dev
      dev="${file%/dev}"
      dev="/dev/${dev##*/}"
      TARGET_UUID=$(identify_target_uuid "$dev" 2>/dev/null || true)

      if [ -n "$TARGET_UUID" ] ; then
        einfo "Identified UUID $TARGET_UUID for $TARGET (via $file)"
        return 0
      fi
    fi
  done
}
# }}}

# modify filesystem settings {{{
tunefs() {
  if [ -n "$TUNE2FS" ] && echo "$MKFS" | grep -q "mkfs.ext" ; then
     einfo "Disabling automatic filesystem check on $TARGET via tune2fs"
     $TUNE2FS "$TARGET"
     eend $?
  fi
}
# }}}

# mount the new partition or if it's a directory do nothing at all {{{
mount_target() {
  if [ -n "$DIRECTORY" ] ; then
     einfo "Running grml-debootstrap on a directory, nothing to mount."
  else
     if grep -q "$TARGET" /proc/mounts ; then
        ewarn "$TARGET already mounted, continuing anyway." ; eend 0
     else
       if ! [ -d "${MNTPOINT}" ] ; then
          [ -n "$VIRTUAL" ] || mkdir -p "${MNTPOINT}"
       fi
       einfo "Mounting $TARGET to $MNTPOINT"
       mkdir -p "$MNTPOINT"
       mount -o rw,suid,dev "$TARGET" "$MNTPOINT"
       eend $?
     fi
  fi
  if [ -n "$ISODIR" ] ; then
     einfo "Mounting Debian image loopback to $MNTPOINT/$ISODIR."
     mkdir -p "$MNTPOINT/$ISODIR"
     mount --bind "$ISODIR" "$MNTPOINT/$ISODIR"
     eend $?
  fi
}
# }}}

# prepare VM image for usage with debootstrap {{{
prepare_vm() {
  if [ -z "$VIRTUAL" ] ; then
     return 0 # be quiet by intention
  fi

  if [ -b "$TARGET" ] && [ -n "$VMFILE" ] ; then
     eerror "Error: specified virtual disk target ($TARGET) is an existing block device."
     eend 1
     bailout 1
  fi
  if [ ! -b "$TARGET" ] && [ -z "$VMFILE" ] ; then
     eerror "Error: specified virtual disk target ($TARGET) does not exist yet."
     eend 1
     bailout 1
  fi

  ORIG_TARGET="$TARGET" # store for later reuse

  if [ -n "$VMFILE" ]; then
    qemu-img create -f raw "${TARGET}" "${VMSIZE}"
  fi
  parted -s "${TARGET}" 'mklabel msdos'
  if [ "$FIXED_DISK_IDENTIFIERS" = "yes" ] ; then
    einfo "Adjusting disk signature to a fixed (non-random) value"
    MBRTMPFILE=$(mktemp)
    dd if="${TARGET}" of="${MBRTMPFILE}" bs=512 count=1
    echo -en "\x41\x41\x41\x41" | dd of="${MBRTMPFILE}" conv=notrunc seek=440 bs=1
    dd if="${MBRTMPFILE}" of="${TARGET}" conv=notrunc
    eend $?
  fi
  parted -s "${TARGET}" 'mkpart primary ext4 2M -1'
  parted -s "${TARGET}" 'set 1 boot on'

  # if dm-mod isn't available then kpartx will fail with
  # "Is device-mapper driver missing from kernel? [...]"
  if ! kpartx -av "$TARGET" >/dev/null 2>&1 || ! grep -q 'device-mapper' /proc/misc >/dev/null 2>&1 ; then
    einfo "Device-mapper not ready yet, trying to load dm-mod module."
    modprobe dm-mod ; eend $?
  fi

  # make sure loop module is present
  if ! losetup -f >/dev/null 2>&1; then
    einfo "Can not find a usable loop device, retrying after loading loop module."
    modprobe loop
    if losetup -f >/dev/null 2>&1; then
      einfo "Found a usable loop device now, continuing."
    else
      eerror "Error finding usable loop device" ; eend 1
      bailout 1
    fi
  fi

  DEVINFO=$(kpartx -asv "$TARGET") # e.g. 'add map loop0p1 (254:5): 0 20477 linear 7:0 3'
  if [ -z "${DEVINFO}" ] ; then
    eerror "Error setting up loopback device." ; eend 1
    bailout 1
  fi

  # hopefully this always works as expected
  LOOP_PART="${DEVINFO##add map }" # 'loop0p1 (254:5): 0 20477 linear 7:0 3'
  LOOP_PART="${LOOP_PART// */}"    # 'loop0p1'
  export TARGET="/dev/mapper/$LOOP_PART" # '/dev/mapper/loop1p1'

  if [ -z "$TARGET" ] ; then
     eerror "Error: target could not be set to according /dev/mapper/* device." ; eend 1
     bailout 1
  fi
}
# }}}

# make VM image bootable and unmount it {{{
finalize_vm() {
  if [ -z "${VIRTUAL}" ] ; then
     return 0
  fi

  if ! mount "${TARGET}" "${MNTPOINT}" ; then
    eerror "Error: Mounting ${TARGET} failed, can not continue." ; eend 1
    bailout 1
  fi

  mount -t proc none "${MNTPOINT}"/proc
  mount -t sysfs none "${MNTPOINT}"/sys
  mount -t devtmpfs udev "${MNTPOINT}"/dev
  mount -t devpts devpts "${MNTPOINT}"/dev/pts

# Has chroot-script installed GRUB to MBR using grub-install (successfully), already?
# chroot-script skips installation for unset ${GRUB}
if [[ -z "${GRUB}" ]] || ! dd if="${GRUB}" bs=512 count=1 2>/dev/null | cat -v | fgrep -q GRUB; then
  einfo "Installing Grub as bootloader."

  if ! chroot "${MNTPOINT}" dpkg --list grub-pc 2>/dev/null | grep -q '^ii' ; then
    echo "Notice: grub-pc package not present yet, installing it therefore."
    # shellcheck disable=SC2086
    DEBIAN_FRONTEND=$DEBIAN_FRONTEND chroot "$MNTPOINT" apt-get -y install $DPKG_OPTIONS grub-pc
  fi

  mkdir -p "${MNTPOINT}/boot/grub"
  if ! [ -d "${MNTPOINT}"/usr/lib/grub/i386-pc/ ] ; then
     eerror "Error: grub not installed inside Virtual Machine. Can not install bootloader." ; eend 1
     bailout 1
  fi

  case "$RELEASE" in
    lenny|squeeze|wheezy)
      cp "${MNTPOINT}"/usr/lib/grub/i386-pc/* "${MNTPOINT}/boot/grub/"
      ;;
    *)
      cp -a "${MNTPOINT}"/usr/lib/grub/i386-pc "${MNTPOINT}/boot/grub/"
      ;;
  esac
  dd if="${MNTPOINT}/usr/lib/grub/i386-pc/boot.img" of="${ORIG_TARGET}" conv=notrunc bs=440 count=1
  chroot "${MNTPOINT}" grub-mkimage -O i386-pc -p "(hd0,msdos1)/boot/grub" -o /tmp/core.img biosdisk part_msdos ext2
  dd if="${MNTPOINT}/tmp/core.img" of="${ORIG_TARGET}" conv=notrunc seek=1
  rm -f "${MNTPOINT}/tmp/core.img"
fi

  einfo "Updating grub configuration file."
  if [ -n "$BOOT_APPEND" ] ; then
     sed -i "/GRUB_CMDLINE_LINUX_DEFAULT/ s#\"\$# ${BOOT_APPEND}\"#" "${MNTPOINT}"/etc/default/grub
  fi
  chroot "${MNTPOINT}" update-grub

  case "$RELEASE" in
    jessie)
      einfo "Applying workaround for GRUB font path bug in jessie (Debian #787685)."
      mkdir -p "${MNTPOINT}/boot/grub/fonts/"
      cp "${MNTPOINT}/usr/share/grub/unicode.pf2" "${MNTPOINT}/boot/grub/fonts/"
      ;;
  esac

  if grep -q '^GRUB_DISABLE_LINUX_UUID=.*true' "${MNTPOINT}"/etc/default/grub 2>/dev/null ; then
    ewarn "GRUB_DISABLE_LINUX_UUID is set to true in /etc/default/grub, not adjusting root= in grub.cfg."
    ewarn "Please note that your system might NOT be able to properly boot."
  else
    einfo "Adjusting grub.cfg for successful boot sequence."
    sed -i "s;root=[^ ]\+;root=UUID=$TARGET_UUID;" "${MNTPOINT}"/boot/grub/grub.cfg
  fi

  umount "${MNTPOINT}"/proc
  umount "${MNTPOINT}"/sys
  umount "${MNTPOINT}"/dev/pts
  try_umount 3 "${MNTPOINT}"/dev
  umount "${MNTPOINT}"
  kpartx -d "${ORIG_TARGET}" >/dev/null
}
# }}}

# install main chroot {{{
debootstrap_system() {
  if [ "$_opt_nodebootstrap" ]; then
     einfo "Skipping debootstrap as requested."
     return
  fi

  if grep -q "$MNTPOINT" /proc/mounts || [ -n "$DIRECTORY" ] ; then
    :
  else
    eerror "Error: $MNTPOINT not mounted, can not continue."
    eend 1 ; exit 1
  fi

  if [ -n "$ISO" ] ; then
    einfo "Running $DEBOOTSTRAP $DEBOOTSTRAP_OPT for release ${RELEASE}${ARCHINFO} using ${ISO}"
    einfo "Executing: $DEBOOTSTRAP $ARCHCMD $KEYRING $DEBOOTSTRAP_OPT $RELEASE $MNTPOINT $ISO"
    # shellcheck disable=SC2086
    "$DEBOOTSTRAP" $ARCHCMD $KEYRING $DEBOOTSTRAP_OPT "$RELEASE" "$MNTPOINT" "$ISO"
    RC=$?
  else
    einfo "Running $DEBOOTSTRAP $DEBOOTSTRAP_OPT for release ${RELEASE}${ARCHINFO} using ${MIRROR}"
    einfo "Executing: $DEBOOTSTRAP $ARCHCMD $KEYRING $DEBOOTSTRAP_OPT $RELEASE $MNTPOINT $MIRROR"
    # shellcheck disable=SC2086
    "$DEBOOTSTRAP" $ARCHCMD $KEYRING $DEBOOTSTRAP_OPT "$RELEASE" "$MNTPOINT" "$MIRROR"
    RC=$?
  fi

  if [ $RC -ne 0 ] ; then
    if [ -r "$MNTPOINT/debootstrap/debootstrap.log" ] && \
      [ -s "$MNTPOINT/debootstrap/debootstrap.log" ] ; then
      einfo "Presenting last ten lines of debootstrap.log:"
      tail -10 "${MNTPOINT}"/debootstrap/debootstrap.log
      einfo "End of debootstrap.log"
    fi
  fi

  eend $RC
}
# }}}

# prepare chroot via chroot-script {{{
preparechroot() {
  einfo "Preparing chroot system"

  # provide variables to chroot system
  CHROOT_VARIABLES="/var/cache/grml-debootstrap/variables_${SHORT_TARGET}"
  touch "$CHROOT_VARIABLES"
  chmod 600 "$CHROOT_VARIABLES" # make sure nobody except root can read it
  echo "# Configuration of ${PN}"                                                                                   > "$CHROOT_VARIABLES"
  # Resorting to sed(1) for escaping since "VAR='${VAR//\'/\'\\\'\'}'" does not work with all versions of Bash,
  #   e.g. not with 4.2.37(1)-release (a.k.a 4.2+dfsg-0.1+deb7u3) of Debian wheezy
  [ -n "$ARCH" ]                && echo "ARCH='$(sed "s,','\\\\'',g" <<<"${ARCH}")'"                               >> "$CHROOT_VARIABLES"
  [ -n "$BACKPORTREPOS" ]       && echo "BACKPORTREPOS='$(sed "s,','\\\\'',g" <<<"${BACKPORTREPOS}")'"             >> "$CHROOT_VARIABLES"
  [ -n "$CHROOT_SCRIPTS" ]      && echo "CHROOT_SCRIPTS='$(sed "s,','\\\\'',g" <<<"${CHROOT_SCRIPTS}")'"           >> "$CHROOT_VARIABLES"
  [ -n "$COMPONENTS" ]          && echo "COMPONENTS='$(sed "s,','\\\\'',g" <<<"${COMPONENTS}")'"                   >> "$CHROOT_VARIABLES"
  [ -n "$CONFFILES" ]           && echo "CONFFILES='$(sed "s,','\\\\'',g" <<<"${CONFFILES}")'"                     >> "$CHROOT_VARIABLES"
  [ -n "$DEBCONF" ]             && echo "DEBCONF='$(sed "s,','\\\\'',g" <<<"${DEBCONF}")'"                         >> "$CHROOT_VARIABLES"
  [ -n "$DEBIAN_FRONTEND" ]     && echo "DEBIAN_FRONTEND='$(sed "s,','\\\\'',g" <<<"${DEBIAN_FRONTEND}")'"         >> "$CHROOT_VARIABLES"
  [ -n "$DEBOOTSTRAP" ]         && echo "DEBOOTSTRAP='$(sed "s,','\\\\'',g" <<<"${DEBOOTSTRAP}")'"                 >> "$CHROOT_VARIABLES"
  [ -n "$DEFAULT_LOCALES" ]     && echo "DEFAULT_LOCALES='$(sed "s,','\\\\'',g" <<<"${DEFAULT_LOCALES}")'"         >> "$CHROOT_VARIABLES"
  [ -n "$DEFAULT_LANGUAGE" ]    && echo "DEFAULT_LANGUAGE='$(sed "s,','\\\\'',g" <<<"${DEFAULT_LANGUAGE}")'"       >> "$CHROOT_VARIABLES"
  [ -n "$EXTRAPACKAGES" ]       && echo "EXTRAPACKAGES='$(sed "s,','\\\\'',g" <<<"${EXTRAPACKAGES}")'"             >> "$CHROOT_VARIABLES"
  [ -n "$EFI" ]                 && echo "EFI='$(sed "s,','\\\\'',g" <<<"${EFI}")'"                                 >> "$CHROOT_VARIABLES"
  [ -n "$FALLBACK_MIRROR" ]     && echo "FALLBACK_MIRROR='$(sed "s,','\\\\'',g" <<<"${FALLBACK_MIRROR}")'"         >> "$CHROOT_VARIABLES"
  [ -n "$FORCE" ]               && echo "FORCE='$(sed "s,','\\\\'',g" <<<"${FORCE}")'"                             >> "$CHROOT_VARIABLES"
  [ -n "$GRMLREPOS" ]           && echo "GRMLREPOS='$(sed "s,','\\\\'',g" <<<"${GRMLREPOS}")'"                     >> "$CHROOT_VARIABLES"
  [ -n "$GRUB" ]                && echo "GRUB='$(sed "s,','\\\\'',g" <<<"${GRUB}")'"                               >> "$CHROOT_VARIABLES"
  [ -n "$HOSTNAME" ]            && echo "HOSTNAME='$(sed "s,','\\\\'',g" <<<"${HOSTNAME}")'"                       >> "$CHROOT_VARIABLES"
  [ -n "$INITRD" ]              && echo "INITRD='$(sed "s,','\\\\'',g" <<<"${INITRD}")'"                           >> "$CHROOT_VARIABLES"
  [ -n "$INSTALL_NOTES" ]       && echo "INSTALL_NOTES='$(sed "s,','\\\\'',g" <<<"${INSTALL_NOTES}")'"             >> "$CHROOT_VARIABLES"
  [ -n "$ISODIR" ]              && echo "ISODIR='$(sed "s,','\\\\'',g" <<<"${ISO}")'"                              >> "$CHROOT_VARIABLES"
  [ -n "$ISO" ]                 && echo "ISO='$(sed "s,','\\\\'',g" <<<"${ISO}")'"                                 >> "$CHROOT_VARIABLES"
  [ -n "$KEEP_SRC_LIST" ]       && echo "KEEP_SRC_LIST='$(sed "s,','\\\\'',g" <<<"${KEEP_SRC_LIST}")'"             >> "$CHROOT_VARIABLES"
  [ -n "$LOCALES" ]             && echo "LOCALES='$(sed "s,','\\\\'',g" <<<"${LOCALES}")'"                         >> "$CHROOT_VARIABLES"
  [ -n "$MIRROR" ]              && echo "MIRROR='$(sed "s,','\\\\'',g" <<<"${MIRROR}")'"                           >> "$CHROOT_VARIABLES"
  [ -n "$MKFS" ]                && echo "MKFS='$(sed "s,','\\\\'',g" <<<"${MKFS}")'"                               >> "$CHROOT_VARIABLES"
  [ -n "$NOPASSWORD" ]          && echo "NOPASSWORD=\"true\""                                                      >> "$CHROOT_VARIABLES"
  [ -n "$NOKERNEL" ]            && echo "NOKERNEL=\"true\""                                                        >> "$CHROOT_VARIABLES"
  [ -n "$PACKAGES" ]            && echo "PACKAGES='$(sed "s,','\\\\'',g" <<<"${PACKAGES}")'"                       >> "$CHROOT_VARIABLES"
  [ -n "$POST_SCRIPTS" ]        && echo "POST_SCRIPTS='$(sed "s,','\\\\'',g" <<<"${POST_SCRIPTS}")'"               >> "$CHROOT_VARIABLES"
  [ -n "$PRE_SCRIPTS" ]         && echo "PRE_SCRIPTS='$(sed "s,','\\\\'',g" <<<"${PRE_SCRIPTS}")'"                 >> "$CHROOT_VARIABLES"
  [ -n "$RECONFIGURE" ]         && echo "RECONFIGURE='$(sed "s,','\\\\'',g" <<<"${RECONFIGURE}")'"                 >> "$CHROOT_VARIABLES"
  [ -n "$RELEASE" ]             && echo "RELEASE='$(sed "s,','\\\\'',g" <<<"${RELEASE}")'"                         >> "$CHROOT_VARIABLES"
  [ -n "$RM_APTCACHE" ]         && echo "RM_APTCACHE='$(sed "s,','\\\\'',g" <<<"${RM_APTCACHE}")'"                 >> "$CHROOT_VARIABLES"
  [ -n "$ROOTPASSWORD" ]        && echo "ROOTPASSWORD='$(sed "s,','\\\\'',g" <<<"${ROOTPASSWORD}")'"               >> "$CHROOT_VARIABLES"
  [ -n "$SCRIPTS" ]             && echo "SCRIPTS='$(sed "s,','\\\\'',g" <<<"${SCRIPTS}")'"                         >> "$CHROOT_VARIABLES"
  [ -n "$SECURE" ]              && echo "SECURE='$(sed "s,','\\\\'',g" <<<"${SECURE}")'"                           >> "$CHROOT_VARIABLES"
  [ -n "$SELECTED_PARTITIONS" ] && echo "SELECTED_PARTITIONS='$(sed "s,','\\\\'',g" <<<"${SELECTED_PARTITIONS}")'" >> "$CHROOT_VARIABLES"
  [ -n "$TARGET" ]              && echo "TARGET='$(sed "s,','\\\\'',g" <<<"${TARGET}")'"                           >> "$CHROOT_VARIABLES"
  [ -n "$UPGRADE_SYSTEM" ]      && echo "UPGRADE_SYSTEM='$(sed "s,','\\\\'',g" <<<"${UPGRADE_SYSTEM}")'"           >> "$CHROOT_VARIABLES"
  [ -n "$TARGET_UUID" ]         && echo "TARGET_UUID='$(sed "s,','\\\\'',g" <<<"${TARGET_UUID}")'"                 >> "$CHROOT_VARIABLES"
  [ -n "$TIMEZONE" ]            && echo "TIMEZONE='$(sed "s,','\\\\'',g" <<<"${TIMEZONE}")'"                       >> "$CHROOT_VARIABLES"
  [ -n "$TUNE2FS" ]             && echo "TUNE2FS='$(sed "s,','\\\\'',g" <<<"${TUNE2FS}")'"                         >> "$CHROOT_VARIABLES"
  [ -n "$VMSIZE" ]              && echo "VMSIZE='$(sed "s,','\\\\'',g" <<<"${VMSIZE}")'"                           >> "$CHROOT_VARIABLES"

  cp $VERBOSE "${CONFFILES}"/chroot-script "${MNTPOINT}"/bin/chroot-script
  chmod 755 "${MNTPOINT}"/bin/chroot-script
  [ -d "$MNTPOINT"/etc/debootstrap/ ] || mkdir "$MNTPOINT"/etc/debootstrap/

  # make sure we have our files for later use via chroot-script
  cp $VERBOSE "${CONFFILES}/config"           "${MNTPOINT}"/etc/debootstrap/
  # make sure we adjust the configuration variables accordingly:
  sed -i "s#RELEASE=.*#RELEASE=\"$RELEASE\"#" "${MNTPOINT}"/etc/debootstrap/config
  sed -i "s#TARGET=.*#TARGET=\"$TARGET\"#"    "${MNTPOINT}"/etc/debootstrap/config
  sed -i "s#GRUB=.*#GRUB=\"$GRUB\"#"          "${MNTPOINT}"/etc/debootstrap/config

  # install notes:
  if [ -n "$INSTALL_NOTES" ] ; then
     [ -r "$INSTALL_NOTES" ] && cp "$INSTALL_NOTES" "${MNTPOINT}"/etc/debootstrap/
  fi

  # package selection:
  if [ "$PACKAGES" = 'yes' ] ; then
    cp $VERBOSE "${_opt_packages:-$CONFFILES/packages}" \
      "${MNTPOINT}"/etc/debootstrap/packages
  fi

  # debconf preseeding:
  _opt_debconf=${_opt_debconf:-$CONFFILES/debconf-selections}
  [ -f "${_opt_debconf}" ] && [ "$DEBCONF" = 'yes' ] && \
    cp $VERBOSE "${_opt_debconf}" "${MNTPOINT}"/etc/debootstrap/debconf-selections

  # copy scripts that should be executed inside the chroot:
  _opt_chroot_scripts=${_opt_chroot_scripts:-$CONFFILES/chroot-scripts/}
  [ -d "$_opt_chroot_scripts" ] && [ "$CHROOT_SCRIPTS" = 'yes' ] && {
    mkdir -p "${MNTPOINT}"/etc/debootstrap/chroot-scripts
    cp -a $VERBOSE "${_opt_chroot_scripts}"/* "${MNTPOINT}"/etc/debootstrap/chroot-scripts/
  }

  # notice: do NOT use $CHROOT_VARIABLES inside chroot but statically file instead!
  cp $VERBOSE "${CHROOT_VARIABLES}" "${MNTPOINT}"/etc/debootstrap/variables

  cp $VERBOSE -a -L "${CONFFILES}"/extrapackages/ "${MNTPOINT}"/etc/debootstrap/

  # make sure we can access network [relevant for cdebootstrap]
  [ -f "${MNTPOINT}"/etc/resolv.conf ] || cp $VERBOSE /etc/resolv.conf "${MNTPOINT}"/etc/resolv.conf

  # setup default locales
  [ -n "$LOCALES" ] && cp $VERBOSE "${CONFFILES}"/locale.gen "${MNTPOINT}"/etc/locale.gen

  # MAKEDEV is just a forking bomb crap, let's do it on our own instead :)
  ( cd "${MNTPOINT}"/dev && tar zxf /etc/debootstrap/devices.tar.gz )

  # copy any existing files to chroot
  [ -d "${CONFFILES}"/bin   ] && cp $VERBOSE -a -L "${CONFFILES}"/bin/*   "${MNTPOINT}"/bin/
  [ -d "${CONFFILES}"/boot  ] && cp $VERBOSE -a -L "${CONFFILES}"/boot/*  "${MNTPOINT}"/boot/
  [ -d "${CONFFILES}"/etc   ] && cp $VERBOSE -a -L "${CONFFILES}"/etc/*   "${MNTPOINT}"/etc/
  [ -d "${CONFFILES}"/sbin  ] && cp $VERBOSE -a -L "${CONFFILES}"/sbin/*  "${MNTPOINT}"/sbin/
  [ -d "${CONFFILES}"/share ] && cp $VERBOSE -a -L "${CONFFILES}"/share/* "${MNTPOINT}"/share/
  [ -d "${CONFFILES}"/usr   ] && cp $VERBOSE -a -L "${CONFFILES}"/usr/*   "${MNTPOINT}"/usr/
  [ -d "${CONFFILES}"/var   ] && cp $VERBOSE -a -L "${CONFFILES}"/var/*   "${MNTPOINT}"/var/

  # network setup
  DEFAULT_INTERFACES="# /etc/network/interfaces - generated by grml-debootstrap

# Include files from /etc/network/interfaces.d when using
# ifupdown v0.7.44 or newer:
#source-directory /etc/network/interfaces.d

auto lo
iface lo inet loopback

allow-hotplug eth0
iface eth0 inet dhcp
"

  if [ -n "$NOINTERFACES" ] ; then
    einfo "Not installing /etc/network/interfaces as requested via --nointerfaces option" ; eend 0
  elif [ -n "$USE_DEFAULT_INTERFACES" ] ; then
    einfo "Installing default /etc/network/interfaces as requested via --defaultinterfaces options."
    echo "$DEFAULT_INTERFACES" > "${MNTPOINT}/etc/network/interfaces"
    eend $?
  elif [ -n "$VIRTUAL" ] ; then
    einfo "Setting up Virtual Machine, installing default /etc/network/interfaces"
    echo "$DEFAULT_INTERFACES" > "${MNTPOINT}/etc/network/interfaces"
    eend $?
  elif [ -r /etc/network/interfaces ] ; then
    einfo "Copying /etc/network/interfaces from host to target system"
    cp $VERBOSE /etc/network/interfaces "${MNTPOINT}/etc/network/interfaces"
    eend $?
  else
    ewarn "Couldn't read /etc/network/interfaces, installing default /etc/network/interfaces"
    echo "$DEFAULT_INTERFACES" > "${MNTPOINT}/etc/network/interfaces"
    eend $?
  fi

  # install config file providing some example entries
  if [ -r /etc/network/interfaces.examples ] && [ ! -r "$MNTPOINT/etc/network/interfaces.examples" ] ; then
     cp /etc/network/interfaces.examples "$MNTPOINT/etc/network/interfaces.examples"
  fi

  eend 0
}
# }}}

# execute all scripts in /etc/debootstrap/pre-scripts/ {{{
execute_pre_scripts() {
  # make sure hostname is set even before chroot-script get executed
  echo "$HOSTNAME" > "$MNTPOINT"/etc/hostname

  # make sure we have $MNTPOINT available for our scripts
  export MNTPOINT

  if [ -d "$_opt_pre_scripts" ] || [ "$PRE_SCRIPTS" = 'yes' ] ; then
    [ -d "$_opt_pre_scripts" ] && pre_scripts="$_opt_pre_scripts" || pre_scripts="${CONFFILES}/pre-scripts/"
    for script in "${pre_scripts}"/* ; do
      if [ -x "$script" ] ; then
        einfo "Executing pre-script $script"
        "$script" ; eend $?
      fi
    done
  fi
}
# }}}

# execute all scripts in /etc/debootstrap/post-scripts/ {{{
execute_post_scripts() {
  # make sure we have $MNTPOINT and HOSTNAME available for our scripts
  export MNTPOINT
  export TARGET_HOSTNAME=$HOSTNAME

  if [ -d "$_opt_scripts" ] || [ "$SCRIPTS" = 'yes' ] ; then
    # legacy support for /etc/debootstrap/scripts/
    [ -d "$_opt_scripts" ] && post_scripts="$_opt_scripts" || post_scripts="${CONFFILES}/scripts/"
    ewarn "Deprecation NOTE: --scripts/SCRIPTS are deprecated, please switch to --post-scripts/POST_SCRIPTS instead."
  elif [ -d "$_opt_post_scripts" ] || [ "$POST_SCRIPTS" = 'yes' ] ; then
    [ -d "$_opt_post_scripts" ] && post_scripts="$_opt_post_scripts" || post_scripts="${CONFFILES}/post-scripts/"
  fi

  if [ -n "$post_scripts" ] ; then
    for script in "${post_scripts}"/* ; do
      if [ -x "$script" ] ; then
        einfo "Executing post-script $script"
        "$script" ; eend $?
      fi
    done
  fi
}
# }}}

# unmount mountpoint {{{
try_umount() {
  local tries=$1
  local mountpoint="$2"

  for (( try=1; try<=tries; try++ )); do
    if [[ ${try} -eq ${tries} ]]; then
      # Last time, show errors this time
      umount "${mountpoint}" && return 0
    else
      # Not last time, hide errors until fatal
      if umount "${mountpoint}" 2>/dev/null ; then
        return 0
      else
        sleep 1
      fi
    fi
  done
  return 1  # Tried enough
}
# }}}

# execute chroot-script {{{
chrootscript() {
  if ! [ -r "$MNTPOINT/bin/chroot-script" ] ; then
    mount_target
  fi

  if ! [ -x "$MNTPOINT/bin/chroot-script" ] ; then
    eerror "Fatal: $MNTPOINT/bin/chroot-script could not be found."
    eend 1
  else
    einfo "Executing chroot-script now"
    mount -t devtmpfs udev "${MNTPOINT}"/dev
    mount -t devpts devpts "${MNTPOINT}"/dev/pts
    if [ "$DEBUG" = "true" ] ; then
      chroot "$MNTPOINT" /bin/bash -x /bin/chroot-script ; RC=$?
    else
      chroot "$MNTPOINT" /bin/chroot-script ; RC=$?
    fi
    try_umount 3 "$MNTPOINT"/dev/pts
    try_umount 3 "$MNTPOINT"/dev
    eend $RC
  fi

  # finally get rid of chroot-script again, there's no good reason to
  # keep it on the installed system
  if grep -q GRML_CHROOT_SCRIPT_MARKER "${MNTPOINT}/bin/chroot-script" ; then
    einfo "Removing chroot-script again"
    rm -f "${MNTPOINT}/bin/chroot-script"
    eend $?
  else
    einfo "Keeping chroot-script as string GRML_CHROOT_SCRIPT_MARKER could not be found"
    eend 0
  fi
}
# }}}

# unmount $MNTPOINT {{{
umount_chroot() {

  # display installation notes:
  if [ -n "$INSTALL_NOTES" ] ; then
     [ -r "${MNTPOINT}/${INSTALL_NOTES}" ] && cat "${MNTPOINT}/${INSTALL_NOTES}"
  fi

  if [ -n "$ISODIR" ] ; then
     if grep -q "$ISODIR" /proc/mounts ; then
        einfo "Unmount $MNTPOINT/$ISODIR"
        umount "$MNTPOINT/$ISODIR"
        eend $?
     fi
  fi

  if grep -q "$MNTPOINT" /proc/mounts ; then
     if [ -n "$PARTITION" ] ; then
        einfo "Unmount $MNTPOINT"
        umount "$MNTPOINT"
        eend $?
     fi
  fi
}
# }}}

# execute filesystem check {{{
fscktool() {
 if [ -n "$VIRTUAL" ] ; then
   einfo "Skipping filesystem check because we deploy a virtual machine."
   return 0
 fi

 if [ "$FSCK" = 'yes' ] ; then
   [ -n "$FSCKTOOL" ] || FSCKTOOL="fsck.${MKFS#mkfs.}"
   einfo "Checking filesystem on $TARGET using $FSCKTOOL"
   "$FSCKTOOL" "$TARGET"
   eend $?
 fi
}
# }}}

# get rid of grml-debootstrap config files {{{
remove_configs() {
  if [ "$REMOVE_CONFIGS" != "yes" ] ; then
    return 0
  fi

  if ! mountpoint "${MNTPOINT}" >/dev/null 2>&1 ; then
    ewarn "Target ${MNTPOINT} doesn't seem to be mounted, can't remove configuration files." ; eend 0
    return 0
  fi

  einfo "Removing configuration files from installed system as requested via --remove-configs / REMOVE_CONFIGS."
  rm -rf "${MNTPOINT}"/etc/debootstrap/
  eend $?
}
# }}}

# now execute all the functions {{{
for i in format_efi_partition prepare_vm mkfs tunefs \
         mount_target mountpoint_to_blockdevice debootstrap_system \
         preparechroot execute_pre_scripts chrootscript execute_post_scripts \
         remove_configs umount_chroot finalize_vm fscktool ; do
    if stage "${i}" ; then
      if "$i" ; then
        stage "${i}" 'done' && rm -f "${STAGES}/${i}"
      else
        bailout 2 "$i"
      fi
    fi
done

cleanup
# }}}

# end dialog of autoinstallation {{{
if [ -n "$AUTOINSTALL" ] ; then
   if dialog --title "${PN}" --pause "Finished execution of ${PN}.
Automatically rebooting in 10 seconds.

Choose Cancel to skip rebooting." 10 60 10 ; then
     noeject noprompt reboot
  fi
else
   einfo "Finished execution of ${PN}. Enjoy your Debian system." ; eend 0
fi
# }}}

## END OF FILE #################################################################
# vim: ai tw=100 expandtab foldmethod=marker shiftwidth=2
